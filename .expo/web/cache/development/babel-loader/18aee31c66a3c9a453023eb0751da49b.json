{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useAuthRequest = useAuthRequest;\nexports.useAuthRequestResult = useAuthRequestResult;\nexports.useAutoDiscovery = useAutoDiscovery;\nexports.useLoadedAuthRequest = useLoadedAuthRequest;\n\nvar _objectWithoutProperties2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutProperties\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _react = require(\"react\");\n\nvar _AuthRequest = require(\"./AuthRequest\");\n\nvar _Discovery = require(\"./Discovery\");\n\nvar _excluded = [\"windowFeatures\"];\n\nfunction useAutoDiscovery(issuerOrDiscovery) {\n  var _useState = (0, _react.useState)(null),\n      _useState2 = (0, _slicedToArray2.default)(_useState, 2),\n      discovery = _useState2[0],\n      setDiscovery = _useState2[1];\n\n  (0, _react.useEffect)(function () {\n    var isAllowed = true;\n    (0, _Discovery.resolveDiscoveryAsync)(issuerOrDiscovery).then(function (discovery) {\n      if (isAllowed) {\n        setDiscovery(discovery);\n      }\n    });\n    return function () {\n      isAllowed = false;\n    };\n  }, [issuerOrDiscovery]);\n  return discovery;\n}\n\nfunction useLoadedAuthRequest(config, discovery, AuthRequestInstance) {\n  var _useState3 = (0, _react.useState)(null),\n      _useState4 = (0, _slicedToArray2.default)(_useState3, 2),\n      request = _useState4[0],\n      setRequest = _useState4[1];\n\n  var scopeString = (0, _react.useMemo)(function () {\n    var _config$scopes;\n\n    return (_config$scopes = config.scopes) == null ? void 0 : _config$scopes.join(',');\n  }, [config.scopes]);\n  var extraParamsString = (0, _react.useMemo)(function () {\n    return JSON.stringify(config.extraParams || {});\n  }, [config.extraParams]);\n  (0, _react.useEffect)(function () {\n    var isMounted = true;\n\n    if (discovery) {\n      var _request = new AuthRequestInstance(config);\n\n      _request.makeAuthUrlAsync(discovery).then(function () {\n        if (isMounted) {\n          setRequest(_request);\n        }\n      });\n    }\n\n    return function () {\n      isMounted = false;\n    };\n  }, [discovery == null ? void 0 : discovery.authorizationEndpoint, config.clientId, config.redirectUri, config.responseType, config.prompt, config.clientSecret, config.codeChallenge, config.state, config.usePKCE, scopeString, extraParamsString]);\n  return request;\n}\n\nfunction useAuthRequestResult(request, discovery) {\n  var customOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var _useState5 = (0, _react.useState)(null),\n      _useState6 = (0, _slicedToArray2.default)(_useState5, 2),\n      result = _useState6[0],\n      setResult = _useState6[1];\n\n  var promptAsync = (0, _react.useCallback)((0, _asyncToGenerator2.default)(function* () {\n    var _customOptions$window;\n\n    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref2$windowFeatures = _ref2.windowFeatures,\n        windowFeatures = _ref2$windowFeatures === void 0 ? {} : _ref2$windowFeatures,\n        options = (0, _objectWithoutProperties2.default)(_ref2, _excluded);\n\n    if (!discovery || !request) {\n      throw new Error('Cannot prompt to authenticate until the request has finished loading.');\n    }\n\n    var inputOptions = Object.assign({}, customOptions, options, {\n      windowFeatures: Object.assign({}, (_customOptions$window = customOptions.windowFeatures) != null ? _customOptions$window : {}, windowFeatures)\n    });\n    var result = yield request == null ? void 0 : request.promptAsync(discovery, inputOptions);\n    setResult(result);\n    return result;\n  }), [request == null ? void 0 : request.url, discovery == null ? void 0 : discovery.authorizationEndpoint]);\n  return [result, promptAsync];\n}\n\nfunction useAuthRequest(config, discovery) {\n  var request = useLoadedAuthRequest(config, discovery, _AuthRequest.AuthRequest);\n\n  var _useAuthRequestResult = useAuthRequestResult(request, discovery),\n      _useAuthRequestResult2 = (0, _slicedToArray2.default)(_useAuthRequestResult, 2),\n      result = _useAuthRequestResult2[0],\n      promptAsync = _useAuthRequestResult2[1];\n\n  return [request, result, promptAsync];\n}","map":{"version":3,"mappings":"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","names":["useAutoDiscovery","issuerOrDiscovery","discovery","setDiscovery","isAllowed","then","useLoadedAuthRequest","config","AuthRequestInstance","request","setRequest","scopeString","scopes","join","extraParamsString","JSON","stringify","extraParams","isMounted","makeAuthUrlAsync","authorizationEndpoint","clientId","redirectUri","responseType","prompt","clientSecret","codeChallenge","state","usePKCE","useAuthRequestResult","customOptions","result","setResult","promptAsync","windowFeatures","options","Error","inputOptions","url","useAuthRequest","AuthRequest"],"sourceRoot":"","sources":["../src/AuthRequestHooks.ts"],"sourcesContent":["import { useCallback, useMemo, useEffect, useState } from 'react';\n\nimport { AuthRequest } from './AuthRequest';\nimport { AuthRequestConfig, AuthRequestPromptOptions } from './AuthRequest.types';\nimport { AuthSessionResult } from './AuthSession.types';\nimport { DiscoveryDocument, IssuerOrDiscovery, resolveDiscoveryAsync } from './Discovery';\n\n// @needsAudit\n/**\n * Given an OpenID Connect issuer URL, this will fetch and return the [`DiscoveryDocument`](#discoverydocument)\n * (a collection of URLs) from the resource provider.\n *\n * @param issuerOrDiscovery URL using the `https` scheme with no query or fragment component that the OP asserts as its Issuer Identifier.\n * @return Returns `null` until the [`DiscoveryDocument`](#discoverydocument) has been fetched from the provided issuer URL.\n *\n * @example\n * ```ts\n * const discovery = useAutoDiscovery('https://example.com/auth');\n * ```\n */\nexport function useAutoDiscovery(issuerOrDiscovery: IssuerOrDiscovery): DiscoveryDocument | null {\n  const [discovery, setDiscovery] = useState<DiscoveryDocument | null>(null);\n\n  useEffect(() => {\n    let isAllowed = true;\n    resolveDiscoveryAsync(issuerOrDiscovery).then((discovery) => {\n      if (isAllowed) {\n        setDiscovery(discovery);\n      }\n    });\n\n    return () => {\n      isAllowed = false;\n    };\n  }, [issuerOrDiscovery]);\n\n  return discovery;\n}\n\nexport function useLoadedAuthRequest(\n  config: AuthRequestConfig,\n  discovery: DiscoveryDocument | null,\n  AuthRequestInstance: typeof AuthRequest\n): AuthRequest | null {\n  const [request, setRequest] = useState<AuthRequest | null>(null);\n  const scopeString = useMemo(() => config.scopes?.join(','), [config.scopes]);\n  const extraParamsString = useMemo(\n    () => JSON.stringify(config.extraParams || {}),\n    [config.extraParams]\n  );\n  useEffect(() => {\n    let isMounted = true;\n\n    if (discovery) {\n      const request = new AuthRequestInstance(config);\n      request.makeAuthUrlAsync(discovery).then(() => {\n        if (isMounted) {\n          setRequest(request);\n        }\n      });\n    }\n    return () => {\n      isMounted = false;\n    };\n  }, [\n    discovery?.authorizationEndpoint,\n    config.clientId,\n    config.redirectUri,\n    config.responseType,\n    config.prompt,\n    config.clientSecret,\n    config.codeChallenge,\n    config.state,\n    config.usePKCE,\n    scopeString,\n    extraParamsString,\n  ]);\n  return request;\n}\n\ntype PromptMethod = (options?: AuthRequestPromptOptions) => Promise<AuthSessionResult>;\n\nexport function useAuthRequestResult(\n  request: AuthRequest | null,\n  discovery: DiscoveryDocument | null,\n  customOptions: AuthRequestPromptOptions = {}\n): [AuthSessionResult | null, PromptMethod] {\n  const [result, setResult] = useState<AuthSessionResult | null>(null);\n\n  const promptAsync = useCallback(\n    async ({ windowFeatures = {}, ...options }: AuthRequestPromptOptions = {}) => {\n      if (!discovery || !request) {\n        throw new Error('Cannot prompt to authenticate until the request has finished loading.');\n      }\n      const inputOptions = {\n        ...customOptions,\n        ...options,\n        windowFeatures: {\n          ...(customOptions.windowFeatures ?? {}),\n          ...windowFeatures,\n        },\n      };\n      const result = await request?.promptAsync(discovery, inputOptions);\n      setResult(result);\n      return result;\n    },\n    [request?.url, discovery?.authorizationEndpoint]\n  );\n\n  return [result, promptAsync];\n}\n\n// @needsAudit\n/**\n * Load an authorization request for a code. When the prompt method completes then the response will be fulfilled.\n *\n * > In order to close the popup window on web, you need to invoke `WebBrowser.maybeCompleteAuthSession()`.\n * > See the [Identity example](/guides/authentication.md#identityserver-4) for more info.\n *\n * If an Implicit grant flow was used, you can pass the `response.params` to `TokenResponse.fromQueryParams()`\n * to get a `TokenResponse` instance which you can use to easily refresh the token.\n *\n * @param config A valid [`AuthRequestConfig`](#authrequestconfig) that specifies what provider to use.\n * @param discovery A loaded [`DiscoveryDocument`](#discoverydocument) with endpoints used for authenticating.\n * Only `authorizationEndpoint` is required for requesting an authorization code.\n *\n * @return Returns a loaded request, a response, and a prompt method in a single array in the following order:\n * - `request` - An instance of [`AuthRequest`](#authrequest) that can be used to prompt the user for authorization.\n *   This will be `null` until the auth request has finished loading.\n * - `response` - This is `null` until `promptAsync` has been invoked. Once fulfilled it will return information about the authorization.\n * - `promptAsync` - When invoked, a web browser will open up and prompt the user for authentication.\n *   Accepts an [`AuthRequestPromptOptions`](#authrequestpromptoptions) object with options about how the prompt will execute.\n *   You can use this to enable the Expo proxy service `auth.expo.io`.\n *\n * @example\n * ```ts\n * const [request, response, promptAsync] = useAuthRequest({ ... }, { ... });\n * ```\n */\nexport function useAuthRequest(\n  config: AuthRequestConfig,\n  discovery: DiscoveryDocument | null\n): [\n  AuthRequest | null,\n  AuthSessionResult | null,\n  (options?: AuthRequestPromptOptions) => Promise<AuthSessionResult>\n] {\n  const request = useLoadedAuthRequest(config, discovery, AuthRequest);\n  const [result, promptAsync] = useAuthRequestResult(request, discovery);\n  return [request, result, promptAsync];\n}\n"]},"metadata":{},"sourceType":"script"}