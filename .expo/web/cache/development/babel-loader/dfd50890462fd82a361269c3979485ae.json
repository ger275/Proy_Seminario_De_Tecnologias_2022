{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.discovery = void 0;\nexports.useAuthRequest = useAuthRequest;\nexports.useIdTokenAuthRequest = useIdTokenAuthRequest;\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _objectWithoutProperties2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutProperties\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _get2 = _interopRequireDefault(require(\"@babel/runtime/helpers/get\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar Application = _interopRequireWildcard(require(\"expo-application\"));\n\nvar _react = require(\"react\");\n\nvar _reactNative = require(\"react-native\");\n\nvar _AuthRequestHooks = require(\"../AuthRequestHooks\");\n\nvar _AuthSession = require(\"../AuthSession\");\n\nvar _TokenRequest = require(\"../TokenRequest\");\n\nvar _ProviderUtils = require(\"./ProviderUtils\");\n\nvar _excluded = [\"language\", \"loginHint\", \"selectAccount\", \"extraParams\", \"clientSecret\"],\n    _excluded2 = [\"extraParams\"];\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nvar settings = {\n  windowFeatures: {\n    width: 515,\n    height: 680\n  },\n  minimumScopes: ['openid', 'https://www.googleapis.com/auth/userinfo.profile', 'https://www.googleapis.com/auth/userinfo.email']\n};\nvar discovery = {\n  authorizationEndpoint: 'https://accounts.google.com/o/oauth2/v2/auth',\n  tokenEndpoint: 'https://oauth2.googleapis.com/token',\n  revocationEndpoint: 'https://oauth2.googleapis.com/revoke',\n  userInfoEndpoint: 'https://openidconnect.googleapis.com/v1/userinfo'\n};\nexports.discovery = discovery;\n\nvar GoogleAuthRequest = function (_AuthRequest) {\n  (0, _inherits2.default)(GoogleAuthRequest, _AuthRequest);\n\n  var _super = _createSuper(GoogleAuthRequest);\n\n  function GoogleAuthRequest(_ref) {\n    var language = _ref.language,\n        loginHint = _ref.loginHint,\n        selectAccount = _ref.selectAccount,\n        _ref$extraParams = _ref.extraParams,\n        extraParams = _ref$extraParams === void 0 ? {} : _ref$extraParams,\n        clientSecret = _ref.clientSecret,\n        config = (0, _objectWithoutProperties2.default)(_ref, _excluded);\n    (0, _classCallCheck2.default)(this, GoogleAuthRequest);\n    var inputParams = Object.assign({}, extraParams);\n    if (language) inputParams.hl = language;\n    if (loginHint) inputParams.login_hint = loginHint;\n    if (selectAccount) inputParams.prompt = _AuthSession.Prompt.SelectAccount;\n    var scopes = (0, _ProviderUtils.applyRequiredScopes)(config.scopes, settings.minimumScopes);\n    var isImplicit = config.responseType === _AuthSession.ResponseType.Token || config.responseType === _AuthSession.ResponseType.IdToken;\n\n    if (isImplicit) {\n      config.usePKCE = false;\n    }\n\n    var inputClientSecret;\n\n    if (config.responseType && config.responseType !== _AuthSession.ResponseType.Code) {\n      inputClientSecret = clientSecret;\n    }\n\n    return _super.call(this, Object.assign({}, config, {\n      clientSecret: inputClientSecret,\n      scopes: scopes,\n      extraParams: inputParams\n    }));\n  }\n\n  (0, _createClass2.default)(GoogleAuthRequest, [{\n    key: \"getAuthRequestConfigAsync\",\n    value: function () {\n      var _getAuthRequestConfigAsync = (0, _asyncToGenerator2.default)(function* () {\n        var _yield$_get$call = yield (0, _get2.default)((0, _getPrototypeOf2.default)(GoogleAuthRequest.prototype), \"getAuthRequestConfigAsync\", this).call(this),\n            _yield$_get$call$extr = _yield$_get$call.extraParams,\n            extraParams = _yield$_get$call$extr === void 0 ? {} : _yield$_get$call$extr,\n            config = (0, _objectWithoutProperties2.default)(_yield$_get$call, _excluded2);\n\n        if (config.responseType === _AuthSession.ResponseType.IdToken && !extraParams.nonce && !this.nonce) {\n          if (!this.nonce) {\n            this.nonce = yield (0, _AuthSession.generateHexStringAsync)(16);\n          }\n\n          extraParams.nonce = this.nonce;\n        }\n\n        return Object.assign({}, config, {\n          extraParams: extraParams\n        });\n      });\n\n      function getAuthRequestConfigAsync() {\n        return _getAuthRequestConfigAsync.apply(this, arguments);\n      }\n\n      return getAuthRequestConfigAsync;\n    }()\n  }]);\n  return GoogleAuthRequest;\n}(_AuthSession.AuthRequest);\n\nfunction useIdTokenAuthRequest(config) {\n  var redirectUriOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var useProxy = (0, _ProviderUtils.useProxyEnabled)(redirectUriOptions);\n  var isWebAuth = useProxy || _reactNative.Platform.OS === 'web';\n  return useAuthRequest(Object.assign({}, config, {\n    responseType: !config.clientSecret && isWebAuth ? _AuthSession.ResponseType.IdToken : undefined\n  }), Object.assign({}, redirectUriOptions, {\n    useProxy: useProxy\n  }));\n}\n\nfunction useAuthRequest() {\n  var _config$scopes;\n\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var redirectUriOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var useProxy = (0, _ProviderUtils.useProxyEnabled)(redirectUriOptions);\n  var clientId = (0, _react.useMemo)(function () {\n    var _config$propertyName;\n\n    var propertyName = useProxy ? 'expoClientId' : _reactNative.Platform.select({\n      ios: 'iosClientId',\n      android: 'androidClientId',\n      default: 'webClientId'\n    });\n    var clientId = (_config$propertyName = config[propertyName]) != null ? _config$propertyName : config.clientId;\n    (0, _ProviderUtils.invariantClientId)(propertyName, clientId, 'Google');\n    return clientId;\n  }, [useProxy, config.expoClientId, config.iosClientId, config.androidClientId, config.webClientId, config.clientId]);\n  var responseType = (0, _react.useMemo)(function () {\n    if (typeof config.responseType !== 'undefined') {\n      return config.responseType;\n    }\n\n    var isInstalledApp = _reactNative.Platform.OS !== 'web' && !useProxy;\n\n    if (config.clientSecret || isInstalledApp) {\n      return _AuthSession.ResponseType.Code;\n    }\n\n    return _AuthSession.ResponseType.Token;\n  }, [config.responseType, config.clientSecret, useProxy]);\n  var redirectUri = (0, _react.useMemo)(function () {\n    if (typeof config.redirectUri !== 'undefined') {\n      return config.redirectUri;\n    }\n\n    return (0, _AuthSession.makeRedirectUri)(Object.assign({\n      native: Application.applicationId + \":/oauthredirect\",\n      useProxy: useProxy\n    }, redirectUriOptions));\n  }, [useProxy, config.redirectUri, redirectUriOptions]);\n  var extraParams = (0, _react.useMemo)(function () {\n    var output = config.extraParams ? Object.assign({}, config.extraParams) : {};\n\n    if (config.language) {\n      output.hl = output.language;\n    }\n\n    if (config.loginHint) {\n      output.login_hint = output.loginHint;\n    }\n\n    if (config.selectAccount) {\n      output.prompt = _AuthSession.Prompt.SelectAccount;\n    }\n\n    return output;\n  }, [config.extraParams, config.language, config.loginHint, config.selectAccount]);\n  var request = (0, _AuthRequestHooks.useLoadedAuthRequest)(Object.assign({}, config, {\n    responseType: responseType,\n    extraParams: extraParams,\n    clientId: clientId,\n    redirectUri: redirectUri\n  }), discovery, GoogleAuthRequest);\n\n  var _useAuthRequestResult = (0, _AuthRequestHooks.useAuthRequestResult)(request, discovery, {\n    useProxy: useProxy,\n    windowFeatures: settings.windowFeatures\n  }),\n      _useAuthRequestResult2 = (0, _slicedToArray2.default)(_useAuthRequestResult, 2),\n      result = _useAuthRequestResult2[0],\n      promptAsync = _useAuthRequestResult2[1];\n\n  var _useState = (0, _react.useState)(null),\n      _useState2 = (0, _slicedToArray2.default)(_useState, 2),\n      fullResult = _useState2[0],\n      setFullResult = _useState2[1];\n\n  var shouldAutoExchangeCode = (0, _react.useMemo)(function () {\n    if (typeof config.shouldAutoExchangeCode !== 'undefined') {\n      return config.shouldAutoExchangeCode;\n    }\n\n    return (result == null ? void 0 : result.type) === 'success' && result.params.code && !result.authentication;\n  }, [config.shouldAutoExchangeCode, result == null ? void 0 : result.type]);\n  (0, _react.useEffect)(function () {\n    var isMounted = true;\n\n    if (shouldAutoExchangeCode && (result == null ? void 0 : result.type) === 'success') {\n      var exchangeRequest = new _TokenRequest.AccessTokenRequest({\n        clientId: clientId,\n        clientSecret: config.clientSecret,\n        redirectUri: redirectUri,\n        scopes: config.scopes,\n        code: result.params.code,\n        extraParams: {\n          code_verifier: (request == null ? void 0 : request.codeVerifier) || ''\n        }\n      });\n      exchangeRequest.performAsync(discovery).then(function (authentication) {\n        if (isMounted) {\n          setFullResult(Object.assign({}, result, {\n            params: Object.assign({\n              id_token: (authentication == null ? void 0 : authentication.idToken) || '',\n              access_token: authentication.accessToken\n            }, result.params),\n            authentication: authentication\n          }));\n        }\n      });\n    } else {\n      setFullResult(result);\n    }\n\n    return function () {\n      isMounted = false;\n    };\n  }, [clientId, redirectUri, shouldAutoExchangeCode, config.clientSecret, (_config$scopes = config.scopes) == null ? void 0 : _config$scopes.join(','), request == null ? void 0 : request.codeVerifier, result]);\n  return [request, fullResult, promptAsync];\n}","map":{"version":3,"mappings":"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","names":["settings","windowFeatures","width","height","minimumScopes","discovery","authorizationEndpoint","tokenEndpoint","revocationEndpoint","userInfoEndpoint","GoogleAuthRequest","language","loginHint","selectAccount","extraParams","clientSecret","config","inputParams","hl","login_hint","prompt","Prompt","SelectAccount","scopes","isImplicit","responseType","ResponseType","Token","IdToken","usePKCE","inputClientSecret","Code","nonce","AuthRequest","useIdTokenAuthRequest","redirectUriOptions","useProxy","isWebAuth","Platform","OS","useAuthRequest","undefined","clientId","propertyName","select","ios","android","default","expoClientId","iosClientId","androidClientId","webClientId","isInstalledApp","redirectUri","native","Application","applicationId","output","request","result","promptAsync","fullResult","setFullResult","shouldAutoExchangeCode","type","params","code","authentication","isMounted","exchangeRequest","AccessTokenRequest","code_verifier","codeVerifier","performAsync","then","id_token","idToken","access_token","accessToken","join"],"sourceRoot":"","sources":["../../src/providers/Google.ts"],"sourcesContent":["import * as Application from 'expo-application';\nimport { useEffect, useMemo, useState } from 'react';\nimport { Platform } from 'react-native';\n\nimport { useAuthRequestResult, useLoadedAuthRequest } from '../AuthRequestHooks';\nimport {\n  AuthRequest,\n  AuthRequestConfig,\n  AuthRequestPromptOptions,\n  AuthSessionRedirectUriOptions,\n  AuthSessionResult,\n  DiscoveryDocument,\n  generateHexStringAsync,\n  makeRedirectUri,\n  Prompt,\n  ResponseType,\n} from '../AuthSession';\nimport { AccessTokenRequest } from '../TokenRequest';\nimport { ProviderAuthRequestConfig } from './Provider.types';\nimport { applyRequiredScopes, invariantClientId, useProxyEnabled } from './ProviderUtils';\n\nconst settings = {\n  windowFeatures: { width: 515, height: 680 },\n  minimumScopes: [\n    'openid',\n    'https://www.googleapis.com/auth/userinfo.profile',\n    'https://www.googleapis.com/auth/userinfo.email',\n  ],\n};\n\nexport const discovery: DiscoveryDocument = {\n  authorizationEndpoint: 'https://accounts.google.com/o/oauth2/v2/auth',\n  tokenEndpoint: 'https://oauth2.googleapis.com/token',\n  revocationEndpoint: 'https://oauth2.googleapis.com/revoke',\n  userInfoEndpoint: 'https://openidconnect.googleapis.com/v1/userinfo',\n};\n\n// @needsAudit\nexport interface GoogleAuthRequestConfig extends ProviderAuthRequestConfig {\n  /**\n   * If the user's email address is known ahead of time, it can be supplied to be the default option.\n   * If the user has approved access for this app in the past then auth may return without any further interaction.\n   */\n  loginHint?: string;\n  /**\n   * When `true`, the service will allow the user to switch between accounts (if possible).\n   * @default false.\n   */\n  selectAccount?: boolean;\n  /**\n   * Proxy client ID for use in the Expo client on iOS and Android.\n   *\n   * This Google Client ID must be setup as follows:\n   *\n   * - **Application Type**: Web Application\n   * - **URIs**: https://auth.expo.io\n   * - **Authorized redirect URIs**: https://auth.expo.io/@your-username/your-project-slug\n   */\n  expoClientId?: string;\n  /**\n   * Expo web client ID for use in the browser.\n   *\n   * This Google Client ID must be setup as follows:\n   *\n   * - **Application Type**: Web Application\n   * - Give it a name (e.g. \"Web App\").\n   * - **URIs** (Authorized JavaScript origins): https://localhost:19006 & https://yourwebsite.com\n   * - **Authorized redirect URIs**: https://localhost:19006 & https://yourwebsite.com\n   * - To test this be sure to start your app with `expo start:web --https`.\n   */\n  webClientId?: string;\n  /**\n   * iOS native client ID for use in standalone, bare workflow, and custom clients.\n   *\n   * This Google Client ID must be setup as follows:\n   *\n   * - **Application Type**: iOS Application\n   * - Give it a name (e.g. \"iOS App\").\n   * - **Bundle ID**: Must match the value of `ios.bundleIdentifier` in your `app.json`.\n   * - Your app needs to conform to the URI scheme matching your bundle identifier.\n   *   - _Standalone_: Automatically added, do nothing.\n   *   - _Bare workflow_: Run `npx uri-scheme add <your bundle id> --ios`\n   * - To test this you can:\n   *   1. Prebuild to generate the native files: `expo prebuild` and run `yarn ios`\n   *   2. Create a custom client: `expo client:ios`\n   *   3. Build a production IPA: `expo build:ios`\n   * - Whenever you change the values in `app.json` you'll need to rebuild the native app.\n   */\n  iosClientId?: string;\n  /**\n   * Android native client ID for use in standalone, and bare workflow.\n   *\n   * This Google Client ID must be setup as follows:\n   *\n   * - **Application Type**: Android Application\n   * - Give it a name (e.g. \"Android App\").\n   * - **Package name**: Must match the value of `android.package` in your `app.json`.\n   * - Your app needs to conform to the URI scheme matching your `android.package` (ex. `com.myname.mycoolapp:/`).\n   *   - _Standalone_: Automatically added, do nothing.\n   *   - _Bare workflow_: Run `npx uri-scheme add <your android.package> --android`\n   * - **Signing-certificate fingerprint**:\n   *   - Run `expo credentials:manager -p android` then select \"Update upload Keystore\" -> \"Generate new keystore\" -> \"Go back to experience overview\"\n   *   - Copy your \"Google Certificate Fingerprint\", it will output a string that looks like `A1:B2:C3` but longer.\n   * - To test this you can:\n   *   1. Prebuild to generate the native files: `expo prebuild` and run `yarn ios`\n   *   2. Build a production IPA: `expo build:android`\n   */\n  androidClientId?: string;\n  /**\n   * Should the hook automatically exchange the response code for an authentication token.\n   *\n   * Defaults to `true` on installed apps (iOS, Android) when `ResponseType.Code` is used (default).\n   */\n  shouldAutoExchangeCode?: boolean;\n  /**\n   * Language code ISO 3166-1 alpha-2 region code, such as 'it' or 'pt-PT'.\n   */\n  language?: string;\n}\n\n// @needsAudit\n/**\n * Extends [`AuthRequest`](#authrequest) and accepts [`GoogleAuthRequestConfig`](#googleauthrequestconfig) in the constructor.\n */\nclass GoogleAuthRequest extends AuthRequest {\n  nonce?: string;\n\n  constructor({\n    language,\n    loginHint,\n    selectAccount,\n    extraParams = {},\n    clientSecret,\n    ...config\n  }: GoogleAuthRequestConfig) {\n    const inputParams = {\n      ...extraParams,\n    };\n    if (language) inputParams.hl = language;\n    if (loginHint) inputParams.login_hint = loginHint;\n    if (selectAccount) inputParams.prompt = Prompt.SelectAccount;\n\n    // Apply the default scopes\n    const scopes = applyRequiredScopes(config.scopes, settings.minimumScopes);\n    const isImplicit =\n      config.responseType === ResponseType.Token || config.responseType === ResponseType.IdToken;\n    if (isImplicit) {\n      // PKCE must be disabled in implicit mode.\n      config.usePKCE = false;\n    }\n    let inputClientSecret: string | undefined;\n    //  Google will throw if you attempt to use the client secret\n    if (config.responseType && config.responseType !== ResponseType.Code) {\n      // TODO: maybe warn that you shouldn't store the client secret on the client\n      inputClientSecret = clientSecret;\n    }\n    super({\n      ...config,\n      clientSecret: inputClientSecret,\n      scopes,\n      extraParams: inputParams,\n    });\n  }\n\n  /**\n   * Load and return a valid auth request based on the input config.\n   */\n  async getAuthRequestConfigAsync(): Promise<AuthRequestConfig> {\n    const { extraParams = {}, ...config } = await super.getAuthRequestConfigAsync();\n    if (config.responseType === ResponseType.IdToken && !extraParams.nonce && !this.nonce) {\n      if (!this.nonce) {\n        this.nonce = await generateHexStringAsync(16);\n      }\n      extraParams.nonce = this.nonce;\n    }\n    return {\n      ...config,\n      extraParams,\n    };\n  }\n}\n\n/**\n * Load an authorization request with an ID Token for authentication with Firebase.\n *\n * Returns a loaded request, a response, and a prompt method.\n * When the prompt method completes then the response will be fulfilled.\n *\n * The id token can be retrieved with `response.params.id_token`.\n *\n * - [Get Started](https://docs.expo.dev/guides/authentication/#google)\n *\n * @param config\n * @param redirectUriOptions\n */\nexport function useIdTokenAuthRequest(\n  config: Partial<GoogleAuthRequestConfig>,\n  redirectUriOptions: Partial<AuthSessionRedirectUriOptions> = {}\n): [\n  GoogleAuthRequest | null,\n  AuthSessionResult | null,\n  (options?: AuthRequestPromptOptions) => Promise<AuthSessionResult>\n] {\n  const useProxy = useProxyEnabled(redirectUriOptions);\n\n  const isWebAuth = useProxy || Platform.OS === 'web';\n\n  return useAuthRequest(\n    {\n      ...config,\n      responseType:\n        // If the client secret is provided then code can be used\n        !config.clientSecret &&\n        // When web auth is used, we can request the `id_token` directly without exchanging a code.\n        isWebAuth\n          ? ResponseType.IdToken\n          : undefined,\n    },\n    { ...redirectUriOptions, useProxy }\n  );\n}\n\n/**\n * Load an authorization request.\n * Returns a loaded request, a response, and a prompt method.\n * When the prompt method completes, then the response will be fulfilled.\n *\n * - [Get Started](https://docs.expo.dev/guides/authentication/#google)\n *\n * @param config\n * @param redirectUriOptions\n */\nexport function useAuthRequest(\n  config: Partial<GoogleAuthRequestConfig> = {},\n  redirectUriOptions: Partial<AuthSessionRedirectUriOptions> = {}\n): [\n  GoogleAuthRequest | null,\n  AuthSessionResult | null,\n  (options?: AuthRequestPromptOptions) => Promise<AuthSessionResult>\n] {\n  const useProxy = useProxyEnabled(redirectUriOptions);\n\n  const clientId = useMemo((): string => {\n    const propertyName = useProxy\n      ? 'expoClientId'\n      : Platform.select({\n          ios: 'iosClientId',\n          android: 'androidClientId',\n          default: 'webClientId',\n        });\n\n    const clientId = config[propertyName as any] ?? config.clientId;\n    invariantClientId(propertyName, clientId, 'Google');\n    return clientId;\n  }, [\n    useProxy,\n    config.expoClientId,\n    config.iosClientId,\n    config.androidClientId,\n    config.webClientId,\n    config.clientId,\n  ]);\n\n  const responseType = useMemo(() => {\n    // Allow overrides.\n    if (typeof config.responseType !== 'undefined') {\n      return config.responseType;\n    }\n    // You can only use `response_token=code` on installed apps (iOS, Android without proxy).\n    // Installed apps can auto exchange without a client secret and get the token and id-token (Firebase).\n    const isInstalledApp = Platform.OS !== 'web' && !useProxy;\n    // If the user provided the client secret (they shouldn't!) then use code exchange by default.\n    if (config.clientSecret || isInstalledApp) {\n      return ResponseType.Code;\n    }\n    // This seems the most pragmatic option since it can result in a full authentication on web and proxy platforms as expected.\n    return ResponseType.Token;\n  }, [config.responseType, config.clientSecret, useProxy]);\n\n  const redirectUri = useMemo((): string => {\n    if (typeof config.redirectUri !== 'undefined') {\n      return config.redirectUri;\n    }\n\n    return makeRedirectUri({\n      native: `${Application.applicationId}:/oauthredirect`,\n      useProxy,\n      ...redirectUriOptions,\n      // native: `com.googleusercontent.apps.${guid}:/oauthredirect`,\n    });\n  }, [useProxy, config.redirectUri, redirectUriOptions]);\n\n  const extraParams = useMemo((): GoogleAuthRequestConfig['extraParams'] => {\n    const output = config.extraParams ? { ...config.extraParams } : {};\n\n    if (config.language) {\n      output.hl = output.language;\n    }\n    if (config.loginHint) {\n      output.login_hint = output.loginHint;\n    }\n    if (config.selectAccount) {\n      output.prompt = Prompt.SelectAccount;\n    }\n    return output;\n  }, [config.extraParams, config.language, config.loginHint, config.selectAccount]);\n\n  const request = useLoadedAuthRequest(\n    {\n      ...config,\n      responseType,\n      extraParams,\n      clientId,\n      redirectUri,\n    },\n    discovery,\n    GoogleAuthRequest\n  );\n\n  const [result, promptAsync] = useAuthRequestResult(request, discovery, {\n    useProxy,\n    windowFeatures: settings.windowFeatures,\n  });\n\n  const [fullResult, setFullResult] = useState<AuthSessionResult | null>(null);\n\n  const shouldAutoExchangeCode = useMemo(() => {\n    // allow overrides\n    if (typeof config.shouldAutoExchangeCode !== 'undefined') {\n      return config.shouldAutoExchangeCode;\n    }\n\n    // has a code to exchange and doesn't have an authentication yet.\n    return result?.type === 'success' && result.params.code && !result.authentication;\n  }, [config.shouldAutoExchangeCode, result?.type]);\n\n  useEffect(() => {\n    let isMounted = true;\n    if (shouldAutoExchangeCode && result?.type === 'success') {\n      const exchangeRequest = new AccessTokenRequest({\n        clientId,\n        clientSecret: config.clientSecret,\n        redirectUri,\n        scopes: config.scopes,\n        code: result.params.code,\n        extraParams: {\n          code_verifier: request?.codeVerifier || '',\n        },\n      });\n      exchangeRequest.performAsync(discovery).then((authentication) => {\n        if (isMounted) {\n          setFullResult({\n            ...result,\n            params: {\n              id_token: authentication?.idToken || '',\n              access_token: authentication.accessToken,\n              ...result.params,\n            },\n            authentication,\n          });\n        }\n      });\n    } else {\n      setFullResult(result);\n    }\n    return () => {\n      isMounted = false;\n    };\n  }, [\n    clientId,\n    redirectUri,\n    shouldAutoExchangeCode,\n    config.clientSecret,\n    config.scopes?.join(','),\n    request?.codeVerifier,\n    result,\n  ]);\n\n  return [request, fullResult, promptAsync];\n}\n"]},"metadata":{},"sourceType":"script"}