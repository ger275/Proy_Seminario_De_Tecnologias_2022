{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getRandomBytes = getRandomBytes;\nexports.getRandomBytesAsync = getRandomBytesAsync;\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _base64Js = require(\"base64-js\");\n\nvar _expoModulesCore = require(\"expo-modules-core\");\n\nvar _ExpoRandom = _interopRequireDefault(require(\"./ExpoRandom\"));\n\nfunction assertByteCount(value, methodName) {\n  if (typeof value !== 'number' || isNaN(value) || Math.floor(value) < 0 || Math.floor(value) > 1024) {\n    throw new TypeError(\"expo-random: \" + methodName + \"(\" + value + \") expected a valid number from range 0...1024\");\n  }\n}\n\nfunction getRandomBytes(byteCount) {\n  assertByteCount(byteCount, 'getRandomBytes');\n  var validByteCount = Math.floor(byteCount);\n\n  if (__DEV__) {\n    if (!global.nativeCallSyncHook || global.__REMOTEDEV__) {\n      var array = new Uint8Array(validByteCount);\n\n      for (var i = 0; i < validByteCount; i++) {\n        array[i] = Math.floor(Math.random() * 256);\n      }\n\n      return array;\n    }\n  }\n\n  if (_ExpoRandom.default.getRandomBytes) {\n    return _ExpoRandom.default.getRandomBytes(validByteCount);\n  } else if (_ExpoRandom.default.getRandomBase64String) {\n    var base64 = _ExpoRandom.default.getRandomBase64String(validByteCount);\n\n    return (0, _base64Js.toByteArray)(base64);\n  } else {\n    throw new _expoModulesCore.UnavailabilityError('expo-random', 'getRandomBytes');\n  }\n}\n\nfunction getRandomBytesAsync(_x) {\n  return _getRandomBytesAsync.apply(this, arguments);\n}\n\nfunction _getRandomBytesAsync() {\n  _getRandomBytesAsync = (0, _asyncToGenerator2.default)(function* (byteCount) {\n    assertByteCount(byteCount, 'getRandomBytesAsync');\n    var validByteCount = Math.floor(byteCount);\n\n    if (_ExpoRandom.default.getRandomBytesAsync) {\n      return yield _ExpoRandom.default.getRandomBytesAsync(validByteCount);\n    } else if (_ExpoRandom.default.getRandomBase64StringAsync) {\n      var base64 = yield _ExpoRandom.default.getRandomBase64StringAsync(validByteCount);\n      return (0, _base64Js.toByteArray)(base64);\n    } else {\n      throw new _expoModulesCore.UnavailabilityError('expo-random', 'getRandomBytesAsync');\n    }\n  });\n  return _getRandomBytesAsync.apply(this, arguments);\n}","map":{"version":3,"mappings":";;;;;;;;;;AAAA;;AACA;;AAEA;;AAEA,SAASA,eAAT,CAAyBC,KAAzB,EAAqCC,UAArC,EAAuD;EACrD,IACE,OAAOD,KAAP,KAAiB,QAAjB,IACAE,KAAK,CAACF,KAAD,CADL,IAEAG,IAAI,CAACC,KAAL,CAAWJ,KAAX,IAAoB,CAFpB,IAGAG,IAAI,CAACC,KAAL,CAAWJ,KAAX,IAAoB,IAJtB,EAKE;IACA,MAAM,IAAIK,SAAJ,mBACYJ,UADZ,SAC0BD,KAD1B,mDAAN;EAGD;AACF;;AAUK,SAAUM,cAAV,CAAyBC,SAAzB,EAA0C;EAC9CR,eAAe,CAACQ,SAAD,EAAY,gBAAZ,CAAf;EACA,IAAMC,cAAc,GAAGL,IAAI,CAACC,KAAL,CAAWG,SAAX,CAAvB;;EACA,IAAIE,OAAJ,EAAa;IACX,IAAI,CAACC,MAAM,CAACC,kBAAR,IAA8BD,MAAM,CAACE,aAAzC,EAAwD;MAEtD,IAAMC,KAAK,GAAG,IAAIC,UAAJ,CAAeN,cAAf,CAAd;;MACA,KAAK,IAAIO,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGP,cAApB,EAAoCO,CAAC,EAArC,EAAyC;QACvCF,KAAK,CAACE,CAAD,CAAL,GAAWZ,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACa,MAAL,KAAgB,GAA3B,CAAX;MACD;;MACD,OAAOH,KAAP;IACD;EACF;;EACD,IAAII,oBAAWX,cAAf,EAA+B;IAC7B,OAAOW,oBAAWX,cAAX,CAA0BE,cAA1B,CAAP;EACD,CAFD,MAEO,IAAIS,oBAAWC,qBAAf,EAAsC;IAC3C,IAAMC,MAAM,GAAGF,oBAAWC,qBAAX,CAAiCV,cAAjC,CAAf;;IACA,OAAO,2BAAYW,MAAZ,CAAP;EACD,CAHM,MAGA;IACL,MAAM,IAAIC,oCAAJ,CAAwB,aAAxB,EAAuC,gBAAvC,CAAN;EACD;AACF;;SASqBC,mB;;;;;yDAAf,WAAmCd,SAAnC,EAAoD;IACzDR,eAAe,CAACQ,SAAD,EAAY,qBAAZ,CAAf;IACA,IAAMC,cAAc,GAAGL,IAAI,CAACC,KAAL,CAAWG,SAAX,CAAvB;;IACA,IAAIU,oBAAWI,mBAAf,EAAoC;MAClC,aAAaJ,oBAAWI,mBAAX,CAA+Bb,cAA/B,CAAb;IACD,CAFD,MAEO,IAAIS,oBAAWK,0BAAf,EAA2C;MAChD,IAAMH,MAAM,SAASF,oBAAWK,0BAAX,CAAsCd,cAAtC,CAArB;MACA,OAAO,2BAAYW,MAAZ,CAAP;IACD,CAHM,MAGA;MACL,MAAM,IAAIC,oCAAJ,CAAwB,aAAxB,EAAuC,qBAAvC,CAAN;IACD;EACF,C","names":["assertByteCount","value","methodName","isNaN","Math","floor","TypeError","getRandomBytes","byteCount","validByteCount","__DEV__","global","nativeCallSyncHook","__REMOTEDEV__","array","Uint8Array","i","random","ExpoRandom","getRandomBase64String","base64","UnavailabilityError","getRandomBytesAsync","getRandomBase64StringAsync"],"sourceRoot":"","sources":["../src/Random.ts"],"sourcesContent":["import { toByteArray } from 'base64-js';\nimport { UnavailabilityError } from 'expo-modules-core';\n\nimport ExpoRandom from './ExpoRandom';\n\nfunction assertByteCount(value: any, methodName: string): void {\n  if (\n    typeof value !== 'number' ||\n    isNaN(value) ||\n    Math.floor(value) < 0 ||\n    Math.floor(value) > 1024\n  ) {\n    throw new TypeError(\n      `expo-random: ${methodName}(${value}) expected a valid number from range 0...1024`\n    );\n  }\n}\n\n// @needsAudit\n/**\n * Generates completely random bytes using native implementations. The `byteCount` property\n * is a `number` indicating the number of bytes to generate in the form of a `Uint8Array`.\n * Falls back to `Math.random` during development to prevent issues with React Native Debugger.\n * @param byteCount - A number within the range from `0` to `1024`. Anything else will throw a `TypeError`.\n * @return An array of random bytes with the same length as the `byteCount`.\n */\nexport function getRandomBytes(byteCount: number): Uint8Array {\n  assertByteCount(byteCount, 'getRandomBytes');\n  const validByteCount = Math.floor(byteCount);\n  if (__DEV__) {\n    if (!global.nativeCallSyncHook || global.__REMOTEDEV__) {\n      // remote javascript debugging is enabled\n      const array = new Uint8Array(validByteCount);\n      for (let i = 0; i < validByteCount; i++) {\n        array[i] = Math.floor(Math.random() * 256);\n      }\n      return array;\n    }\n  }\n  if (ExpoRandom.getRandomBytes) {\n    return ExpoRandom.getRandomBytes(validByteCount);\n  } else if (ExpoRandom.getRandomBase64String) {\n    const base64 = ExpoRandom.getRandomBase64String(validByteCount);\n    return toByteArray(base64);\n  } else {\n    throw new UnavailabilityError('expo-random', 'getRandomBytes');\n  }\n}\n\n// @needsAudit\n/**\n * Generates completely random bytes using native implementations. The `byteCount` property\n * is a `number` indicating the number of bytes to generate in the form of a `Uint8Array`.\n * @param byteCount - A number within the range from `0` to `1024`. Anything else will throw a `TypeError`.\n * @return A promise that fulfills with an array of random bytes with the same length as the `byteCount`.\n */\nexport async function getRandomBytesAsync(byteCount: number): Promise<Uint8Array> {\n  assertByteCount(byteCount, 'getRandomBytesAsync');\n  const validByteCount = Math.floor(byteCount);\n  if (ExpoRandom.getRandomBytesAsync) {\n    return await ExpoRandom.getRandomBytesAsync(validByteCount);\n  } else if (ExpoRandom.getRandomBase64StringAsync) {\n    const base64 = await ExpoRandom.getRandomBase64StringAsync(validByteCount);\n    return toByteArray(base64);\n  } else {\n    throw new UnavailabilityError('expo-random', 'getRandomBytesAsync');\n  }\n}\n"]},"metadata":{},"sourceType":"script"}