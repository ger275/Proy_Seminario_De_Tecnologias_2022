{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TokenResponse = exports.RevokeTokenRequest = exports.RefreshTokenRequest = exports.AccessTokenRequest = void 0;\nexports.exchangeCodeAsync = exchangeCodeAsync;\nexports.fetchUserInfoAsync = fetchUserInfoAsync;\nexports.getCurrentTimeInSeconds = getCurrentTimeInSeconds;\nexports.refreshAsync = refreshAsync;\nexports.revokeAsync = revokeAsync;\n\nvar _get2 = _interopRequireDefault(require(\"@babel/runtime/helpers/get\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _invariant = _interopRequireDefault(require(\"invariant\"));\n\nvar _reactNative = require(\"react-native\");\n\nvar Base64 = _interopRequireWildcard(require(\"./Base64\"));\n\nvar _Errors = require(\"./Errors\");\n\nvar _Fetch = require(\"./Fetch\");\n\nvar _TokenRequest3 = require(\"./TokenRequest.types\");\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction getCurrentTimeInSeconds() {\n  return Math.floor(Date.now() / 1000);\n}\n\nvar TokenResponse = function () {\n  function TokenResponse(response) {\n    var _response$tokenType, _response$issuedAt;\n\n    (0, _classCallCheck2.default)(this, TokenResponse);\n    this.accessToken = response.accessToken;\n    this.tokenType = (_response$tokenType = response.tokenType) != null ? _response$tokenType : 'bearer';\n    this.expiresIn = response.expiresIn;\n    this.refreshToken = response.refreshToken;\n    this.scope = response.scope;\n    this.state = response.state;\n    this.idToken = response.idToken;\n    this.issuedAt = (_response$issuedAt = response.issuedAt) != null ? _response$issuedAt : getCurrentTimeInSeconds();\n  }\n\n  (0, _createClass2.default)(TokenResponse, [{\n    key: \"applyResponseConfig\",\n    value: function applyResponseConfig(response) {\n      var _response$accessToken, _ref, _response$tokenType2, _response$expiresIn, _response$refreshToke, _response$scope, _response$state, _response$idToken, _ref2, _response$issuedAt2;\n\n      this.accessToken = (_response$accessToken = response.accessToken) != null ? _response$accessToken : this.accessToken;\n      this.tokenType = (_ref = (_response$tokenType2 = response.tokenType) != null ? _response$tokenType2 : this.tokenType) != null ? _ref : 'bearer';\n      this.expiresIn = (_response$expiresIn = response.expiresIn) != null ? _response$expiresIn : this.expiresIn;\n      this.refreshToken = (_response$refreshToke = response.refreshToken) != null ? _response$refreshToke : this.refreshToken;\n      this.scope = (_response$scope = response.scope) != null ? _response$scope : this.scope;\n      this.state = (_response$state = response.state) != null ? _response$state : this.state;\n      this.idToken = (_response$idToken = response.idToken) != null ? _response$idToken : this.idToken;\n      this.issuedAt = (_ref2 = (_response$issuedAt2 = response.issuedAt) != null ? _response$issuedAt2 : this.issuedAt) != null ? _ref2 : getCurrentTimeInSeconds();\n    }\n  }, {\n    key: \"getRequestConfig\",\n    value: function getRequestConfig() {\n      return {\n        accessToken: this.accessToken,\n        idToken: this.idToken,\n        refreshToken: this.refreshToken,\n        scope: this.scope,\n        state: this.state,\n        tokenType: this.tokenType,\n        issuedAt: this.issuedAt,\n        expiresIn: this.expiresIn\n      };\n    }\n  }, {\n    key: \"refreshAsync\",\n    value: function () {\n      var _refreshAsync = (0, _asyncToGenerator2.default)(function* (config, discovery) {\n        var _response$refreshToke2;\n\n        var request = new RefreshTokenRequest(Object.assign({}, config, {\n          refreshToken: this.refreshToken\n        }));\n        var response = yield request.performAsync(discovery);\n        response.refreshToken = (_response$refreshToke2 = response.refreshToken) != null ? _response$refreshToke2 : this.refreshToken;\n        var json = response.getRequestConfig();\n        this.applyResponseConfig(json);\n        return this;\n      });\n\n      function refreshAsync(_x, _x2) {\n        return _refreshAsync.apply(this, arguments);\n      }\n\n      return refreshAsync;\n    }()\n  }, {\n    key: \"shouldRefresh\",\n    value: function shouldRefresh() {\n      return !(TokenResponse.isTokenFresh(this) || !this.refreshToken);\n    }\n  }], [{\n    key: \"isTokenFresh\",\n    value: function isTokenFresh(token) {\n      var secondsMargin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 60 * 10 * -1;\n\n      if (!token) {\n        return false;\n      }\n\n      if (token.expiresIn) {\n        var now = getCurrentTimeInSeconds();\n        return now < token.issuedAt + token.expiresIn + secondsMargin;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"fromQueryParams\",\n    value: function fromQueryParams(params) {\n      return new TokenResponse({\n        accessToken: params.access_token,\n        refreshToken: params.refresh_token,\n        scope: params.scope,\n        state: params.state,\n        idToken: params.id_token,\n        tokenType: params.token_type,\n        expiresIn: params.expires_in,\n        issuedAt: params.issued_at\n      });\n    }\n  }]);\n  return TokenResponse;\n}();\n\nexports.TokenResponse = TokenResponse;\n\nvar Request = function () {\n  function Request(request) {\n    (0, _classCallCheck2.default)(this, Request);\n    this.request = request;\n  }\n\n  (0, _createClass2.default)(Request, [{\n    key: \"performAsync\",\n    value: function () {\n      var _performAsync = (0, _asyncToGenerator2.default)(function* (discovery) {\n        throw new Error('performAsync must be extended');\n      });\n\n      function performAsync(_x3) {\n        return _performAsync.apply(this, arguments);\n      }\n\n      return performAsync;\n    }()\n  }, {\n    key: \"getRequestConfig\",\n    value: function getRequestConfig() {\n      throw new Error('getRequestConfig must be extended');\n    }\n  }, {\n    key: \"getQueryBody\",\n    value: function getQueryBody() {\n      throw new Error('getQueryBody must be extended');\n    }\n  }]);\n  return Request;\n}();\n\nvar TokenRequest = function (_Request) {\n  (0, _inherits2.default)(TokenRequest, _Request);\n\n  var _super = _createSuper(TokenRequest);\n\n  function TokenRequest(request, grantType) {\n    var _this;\n\n    (0, _classCallCheck2.default)(this, TokenRequest);\n    _this = _super.call(this, request);\n    _this.grantType = grantType;\n    _this.clientId = request.clientId;\n    _this.clientSecret = request.clientSecret;\n    _this.extraParams = request.extraParams;\n    _this.scopes = request.scopes;\n    return _this;\n  }\n\n  (0, _createClass2.default)(TokenRequest, [{\n    key: \"getHeaders\",\n    value: function getHeaders() {\n      var headers = {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      };\n\n      if (typeof this.clientSecret !== 'undefined') {\n        var encodedClientId = encodeURIComponent(this.clientId);\n        var encodedClientSecret = encodeURIComponent(this.clientSecret);\n        var credentials = encodedClientId + \":\" + encodedClientSecret;\n        var basicAuth = Base64.encodeNoWrap(credentials);\n        headers.Authorization = \"Basic \" + basicAuth;\n      }\n\n      return headers;\n    }\n  }, {\n    key: \"performAsync\",\n    value: function () {\n      var _performAsync2 = (0, _asyncToGenerator2.default)(function* (discovery) {\n        (0, _invariant.default)(discovery.tokenEndpoint, \"Cannot invoke `performAsync()` without a valid tokenEndpoint\");\n        var response = yield (0, _Fetch.requestAsync)(discovery.tokenEndpoint, {\n          dataType: 'json',\n          method: 'POST',\n          headers: this.getHeaders(),\n          body: this.getQueryBody()\n        });\n\n        if ('error' in response) {\n          throw new _Errors.TokenError(response);\n        }\n\n        return new TokenResponse({\n          accessToken: response.access_token,\n          tokenType: response.token_type,\n          expiresIn: response.expires_in,\n          refreshToken: response.refresh_token,\n          scope: response.scope,\n          idToken: response.id_token,\n          issuedAt: response.issued_at\n        });\n      });\n\n      function performAsync(_x4) {\n        return _performAsync2.apply(this, arguments);\n      }\n\n      return performAsync;\n    }()\n  }, {\n    key: \"getQueryBody\",\n    value: function getQueryBody() {\n      var queryBody = {\n        grant_type: this.grantType\n      };\n\n      if (!this.clientSecret) {\n        queryBody.client_id = this.clientId;\n      }\n\n      if (this.scopes) {\n        queryBody.scope = this.scopes.join(' ');\n      }\n\n      if (this.extraParams) {\n        for (var extra in this.extraParams) {\n          if (extra in this.extraParams && !(extra in queryBody)) {\n            queryBody[extra] = this.extraParams[extra];\n          }\n        }\n      }\n\n      return queryBody;\n    }\n  }]);\n  return TokenRequest;\n}(Request);\n\nvar AccessTokenRequest = function (_TokenRequest) {\n  (0, _inherits2.default)(AccessTokenRequest, _TokenRequest);\n\n  var _super2 = _createSuper(AccessTokenRequest);\n\n  function AccessTokenRequest(options) {\n    var _this2;\n\n    (0, _classCallCheck2.default)(this, AccessTokenRequest);\n    (0, _invariant.default)(options.redirectUri, \"`AccessTokenRequest` requires a valid `redirectUri` (it must also match the one used in the auth request). Example: \" + _reactNative.Platform.select({\n      web: 'https://yourwebsite.com/redirect',\n      default: 'myapp://redirect'\n    }));\n    (0, _invariant.default)(options.code, \"`AccessTokenRequest` requires a valid authorization `code`. This is what's received from the authorization server after an auth request.\");\n    _this2 = _super2.call(this, options, _TokenRequest3.GrantType.AuthorizationCode);\n    _this2.code = options.code;\n    _this2.redirectUri = options.redirectUri;\n    return _this2;\n  }\n\n  (0, _createClass2.default)(AccessTokenRequest, [{\n    key: \"getQueryBody\",\n    value: function getQueryBody() {\n      var queryBody = (0, _get2.default)((0, _getPrototypeOf2.default)(AccessTokenRequest.prototype), \"getQueryBody\", this).call(this);\n\n      if (this.redirectUri) {\n        queryBody.redirect_uri = this.redirectUri;\n      }\n\n      if (this.code) {\n        queryBody.code = this.code;\n      }\n\n      return queryBody;\n    }\n  }, {\n    key: \"getRequestConfig\",\n    value: function getRequestConfig() {\n      return {\n        clientId: this.clientId,\n        clientSecret: this.clientSecret,\n        grantType: this.grantType,\n        code: this.code,\n        redirectUri: this.redirectUri,\n        extraParams: this.extraParams,\n        scopes: this.scopes\n      };\n    }\n  }]);\n  return AccessTokenRequest;\n}(TokenRequest);\n\nexports.AccessTokenRequest = AccessTokenRequest;\n\nvar RefreshTokenRequest = function (_TokenRequest2) {\n  (0, _inherits2.default)(RefreshTokenRequest, _TokenRequest2);\n\n  var _super3 = _createSuper(RefreshTokenRequest);\n\n  function RefreshTokenRequest(options) {\n    var _this3;\n\n    (0, _classCallCheck2.default)(this, RefreshTokenRequest);\n    (0, _invariant.default)(options.refreshToken, \"`RefreshTokenRequest` requires a valid `refreshToken`.\");\n    _this3 = _super3.call(this, options, _TokenRequest3.GrantType.RefreshToken);\n    _this3.refreshToken = options.refreshToken;\n    return _this3;\n  }\n\n  (0, _createClass2.default)(RefreshTokenRequest, [{\n    key: \"getQueryBody\",\n    value: function getQueryBody() {\n      var queryBody = (0, _get2.default)((0, _getPrototypeOf2.default)(RefreshTokenRequest.prototype), \"getQueryBody\", this).call(this);\n\n      if (this.refreshToken) {\n        queryBody.refresh_token = this.refreshToken;\n      }\n\n      return queryBody;\n    }\n  }, {\n    key: \"getRequestConfig\",\n    value: function getRequestConfig() {\n      return {\n        clientId: this.clientId,\n        clientSecret: this.clientSecret,\n        grantType: this.grantType,\n        refreshToken: this.refreshToken,\n        extraParams: this.extraParams,\n        scopes: this.scopes\n      };\n    }\n  }]);\n  return RefreshTokenRequest;\n}(TokenRequest);\n\nexports.RefreshTokenRequest = RefreshTokenRequest;\n\nvar RevokeTokenRequest = function (_Request2) {\n  (0, _inherits2.default)(RevokeTokenRequest, _Request2);\n\n  var _super4 = _createSuper(RevokeTokenRequest);\n\n  function RevokeTokenRequest(request) {\n    var _this4;\n\n    (0, _classCallCheck2.default)(this, RevokeTokenRequest);\n    _this4 = _super4.call(this, request);\n    (0, _invariant.default)(request.token, \"`RevokeTokenRequest` requires a valid `token` to revoke.\");\n    _this4.clientId = request.clientId;\n    _this4.clientSecret = request.clientSecret;\n    _this4.token = request.token;\n    _this4.tokenTypeHint = request.tokenTypeHint;\n    return _this4;\n  }\n\n  (0, _createClass2.default)(RevokeTokenRequest, [{\n    key: \"getHeaders\",\n    value: function getHeaders() {\n      var headers = {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      };\n\n      if (typeof this.clientSecret !== 'undefined' && this.clientId) {\n        var encodedClientId = encodeURIComponent(this.clientId);\n        var encodedClientSecret = encodeURIComponent(this.clientSecret);\n        var credentials = encodedClientId + \":\" + encodedClientSecret;\n        var basicAuth = Base64.encodeNoWrap(credentials);\n        headers.Authorization = \"Basic \" + basicAuth;\n      }\n\n      return headers;\n    }\n  }, {\n    key: \"performAsync\",\n    value: function () {\n      var _performAsync3 = (0, _asyncToGenerator2.default)(function* (discovery) {\n        (0, _invariant.default)(discovery.revocationEndpoint, \"Cannot invoke `performAsync()` without a valid revocationEndpoint\");\n        yield (0, _Fetch.requestAsync)(discovery.revocationEndpoint, {\n          method: 'POST',\n          headers: this.getHeaders(),\n          body: this.getQueryBody()\n        });\n        return true;\n      });\n\n      function performAsync(_x5) {\n        return _performAsync3.apply(this, arguments);\n      }\n\n      return performAsync;\n    }()\n  }, {\n    key: \"getRequestConfig\",\n    value: function getRequestConfig() {\n      return {\n        clientId: this.clientId,\n        clientSecret: this.clientSecret,\n        token: this.token,\n        tokenTypeHint: this.tokenTypeHint\n      };\n    }\n  }, {\n    key: \"getQueryBody\",\n    value: function getQueryBody() {\n      var queryBody = {\n        token: this.token\n      };\n\n      if (this.tokenTypeHint) {\n        queryBody.token_type_hint = this.tokenTypeHint;\n      }\n\n      if (this.clientId) {\n        queryBody.client_id = this.clientId;\n      }\n\n      if (this.clientSecret) {\n        queryBody.client_secret = this.clientSecret;\n      }\n\n      return queryBody;\n    }\n  }]);\n  return RevokeTokenRequest;\n}(Request);\n\nexports.RevokeTokenRequest = RevokeTokenRequest;\n\nfunction exchangeCodeAsync(config, discovery) {\n  var request = new AccessTokenRequest(config);\n  return request.performAsync(discovery);\n}\n\nfunction refreshAsync(config, discovery) {\n  var request = new RefreshTokenRequest(config);\n  return request.performAsync(discovery);\n}\n\nfunction revokeAsync(config, discovery) {\n  var request = new RevokeTokenRequest(config);\n  return request.performAsync(discovery);\n}\n\nfunction fetchUserInfoAsync(config, discovery) {\n  if (!discovery.userInfoEndpoint) {\n    throw new Error('User info endpoint is not defined in the service config discovery document');\n  }\n\n  return (0, _Fetch.requestAsync)(discovery.userInfoEndpoint, {\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n      Authorization: \"Bearer \" + config.accessToken\n    },\n    dataType: 'json',\n    method: 'GET'\n  });\n}","map":{"version":3,"mappings":"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","names":["getCurrentTimeInSeconds","Math","floor","Date","now","TokenResponse","response","accessToken","tokenType","expiresIn","refreshToken","scope","state","idToken","issuedAt","config","discovery","request","RefreshTokenRequest","performAsync","json","getRequestConfig","applyResponseConfig","isTokenFresh","token","secondsMargin","params","access_token","refresh_token","id_token","token_type","expires_in","issued_at","Request","Error","TokenRequest","grantType","clientId","clientSecret","extraParams","scopes","headers","encodedClientId","encodeURIComponent","encodedClientSecret","credentials","basicAuth","Base64","encodeNoWrap","Authorization","tokenEndpoint","dataType","method","getHeaders","body","getQueryBody","TokenError","queryBody","grant_type","client_id","join","extra","AccessTokenRequest","options","redirectUri","Platform","select","web","default","code","GrantType","AuthorizationCode","redirect_uri","RefreshToken","RevokeTokenRequest","tokenTypeHint","revocationEndpoint","token_type_hint","client_secret","exchangeCodeAsync","refreshAsync","revokeAsync","fetchUserInfoAsync","userInfoEndpoint"],"sourceRoot":"","sources":["../src/TokenRequest.ts"],"sourcesContent":["import invariant from 'invariant';\nimport { Platform } from 'react-native';\n\nimport * as Base64 from './Base64';\nimport * as ServiceConfig from './Discovery';\nimport { ResponseErrorConfig, TokenError } from './Errors';\nimport { Headers, requestAsync } from './Fetch';\nimport {\n  AccessTokenRequestConfig,\n  GrantType,\n  RefreshTokenRequestConfig,\n  RevokeTokenRequestConfig,\n  ServerTokenResponseConfig,\n  TokenRequestConfig,\n  TokenResponseConfig,\n  TokenType,\n  TokenTypeHint,\n} from './TokenRequest.types';\n\n/**\n * Returns the current time in seconds.\n */\nexport function getCurrentTimeInSeconds(): number {\n  return Math.floor(Date.now() / 1000);\n}\n\n/**\n * Token Response.\n *\n * [Section 5.1](https://tools.ietf.org/html/rfc6749#section-5.1)\n */\nexport class TokenResponse implements TokenResponseConfig {\n  /**\n   * Determines whether a token refresh request must be made to refresh the tokens\n   *\n   * @param token\n   * @param secondsMargin\n   */\n  static isTokenFresh(\n    token: Pick<TokenResponse, 'expiresIn' | 'issuedAt'>,\n    /**\n     * -10 minutes in seconds\n     */\n    secondsMargin: number = 60 * 10 * -1\n  ): boolean {\n    if (!token) {\n      return false;\n    }\n    if (token.expiresIn) {\n      const now = getCurrentTimeInSeconds();\n      return now < token.issuedAt + token.expiresIn + secondsMargin;\n    }\n    // if there is no expiration time but we have an access token, it is assumed to never expire\n    return true;\n  }\n  /**\n   * Creates a `TokenResponse` from query parameters returned from an `AuthRequest`.\n   *\n   * @param params\n   */\n  static fromQueryParams(params: Record<string, any>): TokenResponse {\n    return new TokenResponse({\n      accessToken: params.access_token,\n      refreshToken: params.refresh_token,\n      scope: params.scope,\n      state: params.state,\n      idToken: params.id_token,\n      tokenType: params.token_type,\n      expiresIn: params.expires_in,\n      issuedAt: params.issued_at,\n    });\n  }\n\n  accessToken: string;\n  tokenType: TokenType;\n  expiresIn?: number;\n  refreshToken?: string;\n  scope?: string;\n  state?: string;\n  idToken?: string;\n  issuedAt: number;\n\n  constructor(response: TokenResponseConfig) {\n    this.accessToken = response.accessToken;\n    this.tokenType = response.tokenType ?? 'bearer';\n    this.expiresIn = response.expiresIn;\n    this.refreshToken = response.refreshToken;\n    this.scope = response.scope;\n    this.state = response.state;\n    this.idToken = response.idToken;\n    this.issuedAt = response.issuedAt ?? getCurrentTimeInSeconds();\n  }\n\n  private applyResponseConfig(response: TokenResponseConfig) {\n    this.accessToken = response.accessToken ?? this.accessToken;\n    this.tokenType = response.tokenType ?? this.tokenType ?? 'bearer';\n    this.expiresIn = response.expiresIn ?? this.expiresIn;\n    this.refreshToken = response.refreshToken ?? this.refreshToken;\n    this.scope = response.scope ?? this.scope;\n    this.state = response.state ?? this.state;\n    this.idToken = response.idToken ?? this.idToken;\n    this.issuedAt = response.issuedAt ?? this.issuedAt ?? getCurrentTimeInSeconds();\n  }\n\n  getRequestConfig(): TokenResponseConfig {\n    return {\n      accessToken: this.accessToken,\n      idToken: this.idToken,\n      refreshToken: this.refreshToken,\n      scope: this.scope,\n      state: this.state,\n      tokenType: this.tokenType,\n      issuedAt: this.issuedAt,\n      expiresIn: this.expiresIn,\n    };\n  }\n\n  async refreshAsync(\n    config: Omit<TokenRequestConfig, 'grantType' | 'refreshToken'>,\n    discovery: Pick<ServiceConfig.DiscoveryDocument, 'tokenEndpoint'>\n  ): Promise<TokenResponse> {\n    const request = new RefreshTokenRequest({\n      ...config,\n      refreshToken: this.refreshToken,\n    });\n    const response = await request.performAsync(discovery);\n    // Custom: reuse the refresh token if one wasn't returned\n    response.refreshToken = response.refreshToken ?? this.refreshToken;\n    const json = response.getRequestConfig();\n    this.applyResponseConfig(json);\n    return this;\n  }\n\n  shouldRefresh(): boolean {\n    // no refresh token available and token has expired\n    return !(TokenResponse.isTokenFresh(this) || !this.refreshToken);\n  }\n}\n\nclass Request<T, B> {\n  constructor(protected request: T) {}\n\n  async performAsync(discovery: ServiceConfig.DiscoveryDocument): Promise<B> {\n    throw new Error('performAsync must be extended');\n  }\n\n  getRequestConfig(): T {\n    throw new Error('getRequestConfig must be extended');\n  }\n\n  getQueryBody(): Record<string, string> {\n    throw new Error('getQueryBody must be extended');\n  }\n}\n\n/**\n * A generic token request.\n */\nclass TokenRequest<T extends TokenRequestConfig> extends Request<T, TokenResponse> {\n  readonly clientId: string;\n  readonly clientSecret?: string;\n  readonly scopes?: string[];\n  readonly extraParams?: Record<string, string>;\n\n  constructor(request, public grantType: GrantType) {\n    super(request);\n    this.clientId = request.clientId;\n    this.clientSecret = request.clientSecret;\n    this.extraParams = request.extraParams;\n    this.scopes = request.scopes;\n  }\n\n  getHeaders(): Headers {\n    const headers: Headers = { 'Content-Type': 'application/x-www-form-urlencoded' };\n    if (typeof this.clientSecret !== 'undefined') {\n      // If client secret exists, it should be converted to base64\n      // https://tools.ietf.org/html/rfc6749#section-2.3.1\n      const encodedClientId = encodeURIComponent(this.clientId);\n      const encodedClientSecret = encodeURIComponent(this.clientSecret);\n      const credentials = `${encodedClientId}:${encodedClientSecret}`;\n      const basicAuth = Base64.encodeNoWrap(credentials);\n      headers.Authorization = `Basic ${basicAuth}`;\n    }\n\n    return headers;\n  }\n\n  async performAsync(discovery: Pick<ServiceConfig.DiscoveryDocument, 'tokenEndpoint'>) {\n    // redirect URI must not be nil\n    invariant(\n      discovery.tokenEndpoint,\n      `Cannot invoke \\`performAsync()\\` without a valid tokenEndpoint`\n    );\n    const response = await requestAsync<ServerTokenResponseConfig | ResponseErrorConfig>(\n      discovery.tokenEndpoint,\n      {\n        dataType: 'json',\n        method: 'POST',\n        headers: this.getHeaders(),\n        body: this.getQueryBody(),\n      }\n    );\n\n    if ('error' in response) {\n      throw new TokenError(response);\n    }\n\n    return new TokenResponse({\n      accessToken: response.access_token,\n      tokenType: response.token_type,\n      expiresIn: response.expires_in,\n      refreshToken: response.refresh_token,\n      scope: response.scope,\n      idToken: response.id_token,\n      issuedAt: response.issued_at,\n    });\n  }\n\n  getQueryBody() {\n    const queryBody: Record<string, string> = {\n      grant_type: this.grantType,\n    };\n\n    if (!this.clientSecret) {\n      // Only add the client ID if client secret is not present, otherwise pass the client id with the secret in the request body.\n      queryBody.client_id = this.clientId;\n    }\n\n    if (this.scopes) {\n      queryBody.scope = this.scopes.join(' ');\n    }\n\n    if (this.extraParams) {\n      for (const extra in this.extraParams) {\n        if (extra in this.extraParams && !(extra in queryBody)) {\n          queryBody[extra] = this.extraParams[extra];\n        }\n      }\n    }\n    return queryBody;\n  }\n}\n\n/**\n * Access token request. Exchange an authorization code for a user access token.\n *\n * [Section 4.1.3](https://tools.ietf.org/html/rfc6749#section-4.1.3)\n */\nexport class AccessTokenRequest\n  extends TokenRequest<AccessTokenRequestConfig>\n  implements AccessTokenRequestConfig\n{\n  readonly code: string;\n  readonly redirectUri: string;\n\n  constructor(options: AccessTokenRequestConfig) {\n    invariant(\n      options.redirectUri,\n      `\\`AccessTokenRequest\\` requires a valid \\`redirectUri\\` (it must also match the one used in the auth request). Example: ${Platform.select(\n        {\n          web: 'https://yourwebsite.com/redirect',\n          default: 'myapp://redirect',\n        }\n      )}`\n    );\n\n    invariant(\n      options.code,\n      `\\`AccessTokenRequest\\` requires a valid authorization \\`code\\`. This is what's received from the authorization server after an auth request.`\n    );\n    super(options, GrantType.AuthorizationCode);\n    this.code = options.code;\n    this.redirectUri = options.redirectUri;\n  }\n\n  getQueryBody() {\n    const queryBody: Record<string, string> = super.getQueryBody();\n\n    if (this.redirectUri) {\n      queryBody.redirect_uri = this.redirectUri;\n    }\n\n    if (this.code) {\n      queryBody.code = this.code;\n    }\n\n    return queryBody;\n  }\n\n  getRequestConfig() {\n    return {\n      clientId: this.clientId,\n      clientSecret: this.clientSecret,\n      grantType: this.grantType,\n      code: this.code,\n      redirectUri: this.redirectUri,\n      extraParams: this.extraParams,\n      scopes: this.scopes,\n    };\n  }\n}\n\n/**\n * Refresh request.\n *\n * [Section 6](https://tools.ietf.org/html/rfc6749#section-6)\n */\nexport class RefreshTokenRequest\n  extends TokenRequest<RefreshTokenRequestConfig>\n  implements RefreshTokenRequestConfig\n{\n  readonly refreshToken?: string;\n\n  constructor(options: RefreshTokenRequestConfig) {\n    invariant(options.refreshToken, `\\`RefreshTokenRequest\\` requires a valid \\`refreshToken\\`.`);\n    super(options, GrantType.RefreshToken);\n    this.refreshToken = options.refreshToken;\n  }\n\n  getQueryBody() {\n    const queryBody = super.getQueryBody();\n\n    if (this.refreshToken) {\n      queryBody.refresh_token = this.refreshToken;\n    }\n\n    return queryBody;\n  }\n\n  getRequestConfig() {\n    return {\n      clientId: this.clientId,\n      clientSecret: this.clientSecret,\n      grantType: this.grantType,\n      refreshToken: this.refreshToken,\n      extraParams: this.extraParams,\n      scopes: this.scopes,\n    };\n  }\n}\n\n/**\n * Revocation request for a given token.\n *\n * [Section 2.1](https://tools.ietf.org/html/rfc7009#section-2.1)\n */\nexport class RevokeTokenRequest\n  extends Request<RevokeTokenRequestConfig, boolean>\n  implements RevokeTokenRequestConfig\n{\n  readonly clientId?: string;\n  readonly clientSecret?: string;\n  readonly token: string;\n  readonly tokenTypeHint?: TokenTypeHint;\n\n  constructor(request: RevokeTokenRequestConfig) {\n    super(request);\n    invariant(request.token, `\\`RevokeTokenRequest\\` requires a valid \\`token\\` to revoke.`);\n    this.clientId = request.clientId;\n    this.clientSecret = request.clientSecret;\n    this.token = request.token;\n    this.tokenTypeHint = request.tokenTypeHint;\n  }\n\n  getHeaders(): Headers {\n    const headers: Headers = { 'Content-Type': 'application/x-www-form-urlencoded' };\n    if (typeof this.clientSecret !== 'undefined' && this.clientId) {\n      // If client secret exists, it should be converted to base64\n      // https://tools.ietf.org/html/rfc6749#section-2.3.1\n      const encodedClientId = encodeURIComponent(this.clientId);\n      const encodedClientSecret = encodeURIComponent(this.clientSecret);\n      const credentials = `${encodedClientId}:${encodedClientSecret}`;\n      const basicAuth = Base64.encodeNoWrap(credentials);\n      headers.Authorization = `Basic ${basicAuth}`;\n    }\n\n    return headers;\n  }\n\n  /**\n   * Perform a token revocation request.\n   *\n   * @param discovery The `revocationEndpoint` for a provider.\n   */\n  async performAsync(discovery: Pick<ServiceConfig.DiscoveryDocument, 'revocationEndpoint'>) {\n    invariant(\n      discovery.revocationEndpoint,\n      `Cannot invoke \\`performAsync()\\` without a valid revocationEndpoint`\n    );\n    await requestAsync<boolean>(discovery.revocationEndpoint, {\n      method: 'POST',\n      headers: this.getHeaders(),\n      body: this.getQueryBody(),\n    });\n\n    return true;\n  }\n\n  getRequestConfig() {\n    return {\n      clientId: this.clientId,\n      clientSecret: this.clientSecret,\n      token: this.token,\n      tokenTypeHint: this.tokenTypeHint,\n    };\n  }\n\n  getQueryBody(): Record<string, string> {\n    const queryBody: Record<string, string> = { token: this.token };\n    if (this.tokenTypeHint) {\n      queryBody.token_type_hint = this.tokenTypeHint;\n    }\n    // Include client creds https://tools.ietf.org/html/rfc6749#section-2.3.1\n    if (this.clientId) {\n      queryBody.client_id = this.clientId;\n    }\n    if (this.clientSecret) {\n      queryBody.client_secret = this.clientSecret;\n    }\n    return queryBody;\n  }\n}\n\n// @needsAudit\n/**\n * Exchange an authorization code for an access token that can be used to get data from the provider.\n *\n * @param config Configuration used to exchange the code for a token.\n * @param discovery The `tokenEndpoint` for a provider.\n * @return Returns a discovery document with a valid `tokenEndpoint` URL.\n */\nexport function exchangeCodeAsync(\n  config: AccessTokenRequestConfig,\n  discovery: Pick<ServiceConfig.DiscoveryDocument, 'tokenEndpoint'>\n): Promise<TokenResponse> {\n  const request = new AccessTokenRequest(config);\n  return request.performAsync(discovery);\n}\n\n// @needsAudit\n/**\n * Refresh an access token.\n * - If the provider didn't return a `refresh_token` then the access token may not be refreshed.\n * - If the provider didn't return a `expires_in` then it's assumed that the token does not expire.\n * - Determine if a token needs to be refreshed via `TokenResponse.isTokenFresh()` or `shouldRefresh()` on an instance of `TokenResponse`.\n *\n * @see [Section 6](https://tools.ietf.org/html/rfc6749#section-6).\n *\n * @param config Configuration used to refresh the given access token.\n * @param discovery The `tokenEndpoint` for a provider.\n * @return Returns a discovery document with a valid `tokenEndpoint` URL.\n */\nexport function refreshAsync(\n  config: RefreshTokenRequestConfig,\n  discovery: Pick<ServiceConfig.DiscoveryDocument, 'tokenEndpoint'>\n): Promise<TokenResponse> {\n  const request = new RefreshTokenRequest(config);\n  return request.performAsync(discovery);\n}\n\n// @needsAudit\n/**\n * Revoke a token with a provider. This makes the token unusable, effectively requiring the user to login again.\n *\n * @param config Configuration used to revoke a refresh or access token.\n * @param discovery The `revocationEndpoint` for a provider.\n * @return Returns a discovery document with a valid `revocationEndpoint` URL. Many providers do not support this feature.\n */\nexport function revokeAsync(\n  config: RevokeTokenRequestConfig,\n  discovery: Pick<ServiceConfig.DiscoveryDocument, 'revocationEndpoint'>\n): Promise<boolean> {\n  const request = new RevokeTokenRequest(config);\n  return request.performAsync(discovery);\n}\n\n/**\n * Fetch generic user info from the provider's OpenID Connect `userInfoEndpoint` (if supported).\n *\n * @see [UserInfo](https://openid.net/specs/openid-connect-core-1_0.html#UserInfo).\n *\n * @param config The `accessToken` for a user, returned from a code exchange or auth request.\n * @param discovery The `userInfoEndpoint` for a provider.\n */\nexport function fetchUserInfoAsync(\n  config: Pick<TokenResponse, 'accessToken'>,\n  discovery: Pick<ServiceConfig.DiscoveryDocument, 'userInfoEndpoint'>\n): Promise<Record<string, any>> {\n  if (!discovery.userInfoEndpoint) {\n    throw new Error('User info endpoint is not defined in the service config discovery document');\n  }\n  return requestAsync<Record<string, any>>(discovery.userInfoEndpoint, {\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n      Authorization: `Bearer ${config.accessToken}`,\n    },\n    dataType: 'json',\n    method: 'GET',\n  });\n}\n"]},"metadata":{},"sourceType":"script"}