{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _expoModulesCore = require(\"expo-modules-core\");\n\nvar _Crypto = require(\"./Crypto.types\");\n\nvar _default = {\n  get name() {\n    return 'ExpoCrypto';\n  },\n\n  digestStringAsync: function () {\n    var _digestStringAsync = (0, _asyncToGenerator2.default)(function* (algorithm, data, options) {\n      if (!crypto.subtle) {\n        throw new _expoModulesCore.CodedError('ERR_CRYPTO_UNAVAILABLE', 'Access to the WebCrypto API is restricted to secure origins (https).');\n      }\n\n      var encoder = new TextEncoder();\n      var buffer = encoder.encode(data);\n      var hashedData = yield crypto.subtle.digest(algorithm, buffer);\n\n      if (options.encoding === _Crypto.CryptoEncoding.HEX) {\n        return hexString(hashedData);\n      } else if (options.encoding === _Crypto.CryptoEncoding.BASE64) {\n        return btoa(String.fromCharCode.apply(String, (0, _toConsumableArray2.default)(new Uint8Array(hashedData))));\n      }\n\n      throw new _expoModulesCore.CodedError('ERR_CRYPTO_DIGEST', 'Invalid encoding type provided.');\n    });\n\n    function digestStringAsync(_x, _x2, _x3) {\n      return _digestStringAsync.apply(this, arguments);\n    }\n\n    return digestStringAsync;\n  }()\n};\nexports.default = _default;\n\nfunction hexString(buffer) {\n  var byteArray = new Uint8Array(buffer);\n  var hexCodes = (0, _toConsumableArray2.default)(byteArray).map(function (value) {\n    var hexCode = value.toString(16);\n    var paddedHexCode = hexCode.padStart(2, '0');\n    return paddedHexCode;\n  });\n  return hexCodes.join('');\n}","map":{"version":3,"mappings":";;;;;;;;;;;AAAA;;AAEA;;eAEe;EACb,IAAIA,IAAJ,GAAQ;IACN,OAAO,YAAP;EACD,CAHY;;EAIPC,iBAJO;IAAA,oEAKXC,SALW,EAMXC,IANW,EAOXC,OAPW,EAOiB;MAE5B,IAAI,CAACC,MAAM,CAACC,MAAZ,EAAoB;QAClB,MAAM,IAAIC,2BAAJ,CACJ,wBADI,EAEJ,sEAFI,CAAN;MAID;;MACD,IAAMC,OAAO,GAAG,IAAIC,WAAJ,EAAhB;MACA,IAAMC,MAAM,GAAGF,OAAO,CAACG,MAAR,CAAeR,IAAf,CAAf;MACA,IAAMS,UAAU,SAASP,MAAM,CAACC,MAAP,CAAcO,MAAd,CAAqBX,SAArB,EAAgCQ,MAAhC,CAAzB;;MACA,IAAIN,OAAO,CAACU,QAAR,KAAqBC,uBAAeC,GAAxC,EAA6C;QAC3C,OAAOC,SAAS,CAACL,UAAD,CAAhB;MACD,CAFD,MAEO,IAAIR,OAAO,CAACU,QAAR,KAAqBC,uBAAeG,MAAxC,EAAgD;QACrD,OAAOC,IAAI,CAACC,MAAM,CAACC,YAAP,aAAM,mCAAiB,IAAIC,UAAJ,CAAeV,UAAf,CAAjB,EAAP,CAAX;MACD;;MACD,MAAM,IAAIL,2BAAJ,CAAe,mBAAf,EAAoC,iCAApC,CAAN;IACD,CAxBY;;IAAA;MAAA;IAAA;;IAAA;EAAA;AAAA,C;;;AA2Bf,SAASU,SAAT,CAAmBP,MAAnB,EAAsC;EACpC,IAAMa,SAAS,GAAG,IAAID,UAAJ,CAAeZ,MAAf,CAAlB;EAEA,IAAMc,QAAQ,GAAG,iCAAID,SAAJ,EAAeE,GAAf,CAAmB,UAACC,KAAD,EAAU;IAC5C,IAAMC,OAAO,GAAGD,KAAK,CAACE,QAAN,CAAe,EAAf,CAAhB;IACA,IAAMC,aAAa,GAAGF,OAAO,CAACG,QAAR,CAAiB,CAAjB,EAAoB,GAApB,CAAtB;IACA,OAAOD,aAAP;EACD,CAJgB,CAAjB;EAMA,OAAOL,QAAQ,CAACO,IAAT,CAAc,EAAd,CAAP;AACD","names":["name","digestStringAsync","algorithm","data","options","crypto","subtle","CodedError","encoder","TextEncoder","buffer","encode","hashedData","digest","encoding","CryptoEncoding","HEX","hexString","BASE64","btoa","String","fromCharCode","Uint8Array","byteArray","hexCodes","map","value","hexCode","toString","paddedHexCode","padStart","join"],"sourceRoot":"","sources":["../src/ExpoCrypto.web.ts"],"sourcesContent":["import { CodedError } from 'expo-modules-core';\n\nimport { CryptoDigestAlgorithm, CryptoEncoding, CryptoDigestOptions } from './Crypto.types';\n\nexport default {\n  get name(): string {\n    return 'ExpoCrypto';\n  },\n  async digestStringAsync(\n    algorithm: CryptoDigestAlgorithm,\n    data: string,\n    options: CryptoDigestOptions\n  ): Promise<string> {\n    if (!crypto.subtle) {\n      throw new CodedError(\n        'ERR_CRYPTO_UNAVAILABLE',\n        'Access to the WebCrypto API is restricted to secure origins (https).'\n      );\n    }\n    const encoder = new TextEncoder();\n    const buffer = encoder.encode(data);\n    const hashedData = await crypto.subtle.digest(algorithm, buffer);\n    if (options.encoding === CryptoEncoding.HEX) {\n      return hexString(hashedData);\n    } else if (options.encoding === CryptoEncoding.BASE64) {\n      return btoa(String.fromCharCode(...new Uint8Array(hashedData)));\n    }\n    throw new CodedError('ERR_CRYPTO_DIGEST', 'Invalid encoding type provided.');\n  },\n};\n\nfunction hexString(buffer: ArrayBuffer): string {\n  const byteArray = new Uint8Array(buffer);\n\n  const hexCodes = [...byteArray].map((value) => {\n    const hexCode = value.toString(16);\n    const paddedHexCode = hexCode.padStart(2, '0');\n    return paddedHexCode;\n  });\n\n  return hexCodes.join('');\n}\n"]},"metadata":{},"sourceType":"script"}