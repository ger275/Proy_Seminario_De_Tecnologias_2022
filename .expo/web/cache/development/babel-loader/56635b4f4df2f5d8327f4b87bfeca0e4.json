{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _exportNames = {\n  startAsync: true,\n  dismiss: true,\n  getDefaultReturnUrl: true,\n  getRedirectUrl: true,\n  makeRedirectUri: true,\n  loadAsync: true,\n  AuthRequest: true,\n  CodeChallengeMethod: true,\n  Prompt: true,\n  ResponseType: true,\n  fetchDiscoveryAsync: true,\n  resolveDiscoveryAsync: true,\n  generateHexStringAsync: true,\n  useAutoDiscovery: true,\n  useAuthRequest: true,\n  AuthError: true,\n  TokenError: true,\n  TokenResponse: true,\n  AccessTokenRequest: true,\n  RefreshTokenRequest: true,\n  RevokeTokenRequest: true,\n  revokeAsync: true,\n  refreshAsync: true,\n  exchangeCodeAsync: true,\n  fetchUserInfoAsync: true\n};\nObject.defineProperty(exports, \"AccessTokenRequest\", {\n  enumerable: true,\n  get: function get() {\n    return _TokenRequest.AccessTokenRequest;\n  }\n});\nObject.defineProperty(exports, \"AuthError\", {\n  enumerable: true,\n  get: function get() {\n    return _Errors.AuthError;\n  }\n});\nObject.defineProperty(exports, \"AuthRequest\", {\n  enumerable: true,\n  get: function get() {\n    return _AuthRequest.AuthRequest;\n  }\n});\nObject.defineProperty(exports, \"CodeChallengeMethod\", {\n  enumerable: true,\n  get: function get() {\n    return _AuthRequest2.CodeChallengeMethod;\n  }\n});\nObject.defineProperty(exports, \"Prompt\", {\n  enumerable: true,\n  get: function get() {\n    return _AuthRequest2.Prompt;\n  }\n});\nObject.defineProperty(exports, \"RefreshTokenRequest\", {\n  enumerable: true,\n  get: function get() {\n    return _TokenRequest.RefreshTokenRequest;\n  }\n});\nObject.defineProperty(exports, \"ResponseType\", {\n  enumerable: true,\n  get: function get() {\n    return _AuthRequest2.ResponseType;\n  }\n});\nObject.defineProperty(exports, \"RevokeTokenRequest\", {\n  enumerable: true,\n  get: function get() {\n    return _TokenRequest.RevokeTokenRequest;\n  }\n});\nObject.defineProperty(exports, \"TokenError\", {\n  enumerable: true,\n  get: function get() {\n    return _Errors.TokenError;\n  }\n});\nObject.defineProperty(exports, \"TokenResponse\", {\n  enumerable: true,\n  get: function get() {\n    return _TokenRequest.TokenResponse;\n  }\n});\nexports.dismiss = dismiss;\nObject.defineProperty(exports, \"exchangeCodeAsync\", {\n  enumerable: true,\n  get: function get() {\n    return _TokenRequest.exchangeCodeAsync;\n  }\n});\nObject.defineProperty(exports, \"fetchDiscoveryAsync\", {\n  enumerable: true,\n  get: function get() {\n    return _Discovery.fetchDiscoveryAsync;\n  }\n});\nObject.defineProperty(exports, \"fetchUserInfoAsync\", {\n  enumerable: true,\n  get: function get() {\n    return _TokenRequest.fetchUserInfoAsync;\n  }\n});\nObject.defineProperty(exports, \"generateHexStringAsync\", {\n  enumerable: true,\n  get: function get() {\n    return _PKCE.generateHexStringAsync;\n  }\n});\nexports.getDefaultReturnUrl = void 0;\nexports.getRedirectUrl = getRedirectUrl;\nexports.loadAsync = loadAsync;\nexports.makeRedirectUri = makeRedirectUri;\nObject.defineProperty(exports, \"refreshAsync\", {\n  enumerable: true,\n  get: function get() {\n    return _TokenRequest.refreshAsync;\n  }\n});\nObject.defineProperty(exports, \"resolveDiscoveryAsync\", {\n  enumerable: true,\n  get: function get() {\n    return _Discovery.resolveDiscoveryAsync;\n  }\n});\nObject.defineProperty(exports, \"revokeAsync\", {\n  enumerable: true,\n  get: function get() {\n    return _TokenRequest.revokeAsync;\n  }\n});\nexports.startAsync = startAsync;\nObject.defineProperty(exports, \"useAuthRequest\", {\n  enumerable: true,\n  get: function get() {\n    return _AuthRequestHooks.useAuthRequest;\n  }\n});\nObject.defineProperty(exports, \"useAutoDiscovery\", {\n  enumerable: true,\n  get: function get() {\n    return _AuthRequestHooks.useAutoDiscovery;\n  }\n});\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _expoConstants = _interopRequireWildcard(require(\"expo-constants\"));\n\nvar Linking = _interopRequireWildcard(require(\"expo-linking\"));\n\nvar _expoModulesCore = require(\"expo-modules-core\");\n\nvar _expoWebBrowser = require(\"expo-web-browser\");\n\nvar _AuthRequest = require(\"./AuthRequest\");\n\nvar _AuthRequest2 = require(\"./AuthRequest.types\");\n\nvar _Discovery = require(\"./Discovery\");\n\nvar _PKCE = require(\"./PKCE\");\n\nvar _QueryParams = require(\"./QueryParams\");\n\nvar _SessionUrlProvider = _interopRequireDefault(require(\"./SessionUrlProvider\"));\n\nvar _AuthRequestHooks = require(\"./AuthRequestHooks\");\n\nvar _Errors = require(\"./Errors\");\n\nvar _TokenRequest = require(\"./TokenRequest\");\n\nvar _TokenRequest2 = require(\"./TokenRequest.types\");\n\nObject.keys(_TokenRequest2).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _TokenRequest2[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _TokenRequest2[key];\n    }\n  });\n});\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nvar _authLock = false;\n\nfunction startAsync(_x) {\n  return _startAsync.apply(this, arguments);\n}\n\nfunction _startAsync() {\n  _startAsync = (0, _asyncToGenerator2.default)(function* (options) {\n    var authUrl = options.authUrl;\n\n    if (!authUrl) {\n      throw new Error('No authUrl provided to AuthSession.startAsync. An authUrl is required -- it points to the page where the user will be able to sign in.');\n    }\n\n    if (_authLock) {\n      if (__DEV__) {\n        console.warn('Attempted to call AuthSession.startAsync multiple times while already active. Only one AuthSession can be active at any given time.');\n      }\n\n      return {\n        type: 'locked'\n      };\n    }\n\n    var returnUrl = options.returnUrl || _SessionUrlProvider.default.getDefaultReturnUrl();\n\n    var startUrl = _SessionUrlProvider.default.getStartUrl(authUrl, returnUrl, options.projectNameForProxy);\n\n    var showInRecents = options.showInRecents || false;\n    _authLock = true;\n    var result;\n\n    try {\n      result = yield _openWebBrowserAsync(startUrl, returnUrl, showInRecents);\n    } finally {\n      _authLock = false;\n    }\n\n    if (!result) {\n      throw new Error('Unexpected missing AuthSession result');\n    }\n\n    if (!('url' in result)) {\n      if ('type' in result) {\n        return result;\n      } else {\n        throw new Error('Unexpected AuthSession result with missing type');\n      }\n    }\n\n    var _getQueryParams = (0, _QueryParams.getQueryParams)(result.url),\n        params = _getQueryParams.params,\n        errorCode = _getQueryParams.errorCode;\n\n    return {\n      type: errorCode ? 'error' : 'success',\n      params: params,\n      errorCode: errorCode,\n      authentication: null,\n      url: result.url\n    };\n  });\n  return _startAsync.apply(this, arguments);\n}\n\nfunction dismiss() {\n  (0, _expoWebBrowser.dismissAuthSession)();\n}\n\nvar getDefaultReturnUrl = _SessionUrlProvider.default.getDefaultReturnUrl;\nexports.getDefaultReturnUrl = getDefaultReturnUrl;\n\nfunction getRedirectUrl(path) {\n  return _SessionUrlProvider.default.getRedirectUrl({\n    urlPath: path\n  });\n}\n\nfunction makeRedirectUri() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      native = _ref.native,\n      scheme = _ref.scheme,\n      isTripleSlashed = _ref.isTripleSlashed,\n      queryParams = _ref.queryParams,\n      path = _ref.path,\n      preferLocalhost = _ref.preferLocalhost,\n      useProxy = _ref.useProxy,\n      projectNameForProxy = _ref.projectNameForProxy;\n\n  if (_expoModulesCore.Platform.OS !== 'web' && native && [_expoConstants.ExecutionEnvironment.Standalone, _expoConstants.ExecutionEnvironment.Bare].includes(_expoConstants.default.executionEnvironment)) {\n    return native;\n  }\n\n  if (!useProxy || _expoModulesCore.Platform.OS === 'web') {\n    var url = Linking.createURL(path || '', {\n      isTripleSlashed: isTripleSlashed,\n      scheme: scheme,\n      queryParams: queryParams\n    });\n\n    if (preferLocalhost) {\n      var ipAddress = url.match(/\\b(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b/);\n\n      if (ipAddress != null && ipAddress.length) {\n        var _url$split = url.split(ipAddress[0]),\n            _url$split2 = (0, _slicedToArray2.default)(_url$split, 2),\n            protocol = _url$split2[0],\n            _path = _url$split2[1];\n\n        return protocol + \"localhost\" + _path;\n      }\n    }\n\n    return url;\n  }\n\n  return _SessionUrlProvider.default.getRedirectUrl({\n    urlPath: path,\n    projectNameForProxy: projectNameForProxy\n  });\n}\n\nfunction loadAsync(_x2, _x3) {\n  return _loadAsync.apply(this, arguments);\n}\n\nfunction _loadAsync() {\n  _loadAsync = (0, _asyncToGenerator2.default)(function* (config, issuerOrDiscovery) {\n    var request = new _AuthRequest.AuthRequest(config);\n    var discovery = yield (0, _Discovery.resolveDiscoveryAsync)(issuerOrDiscovery);\n    yield request.makeAuthUrlAsync(discovery);\n    return request;\n  });\n  return _loadAsync.apply(this, arguments);\n}\n\nfunction _openWebBrowserAsync(_x4, _x5, _x6) {\n  return _openWebBrowserAsync2.apply(this, arguments);\n}\n\nfunction _openWebBrowserAsync2() {\n  _openWebBrowserAsync2 = (0, _asyncToGenerator2.default)(function* (startUrl, returnUrl, showInRecents) {\n    var result = yield (0, _expoWebBrowser.openAuthSessionAsync)(startUrl, returnUrl, {\n      showInRecents: showInRecents\n    });\n\n    if (result.type === 'cancel' || result.type === 'dismiss') {\n      return {\n        type: result.type\n      };\n    }\n\n    return result;\n  });\n  return _openWebBrowserAsync2.apply(this, arguments);\n}","map":{"version":3,"mappings":"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","names":["_authLock","startAsync","options","authUrl","Error","__DEV__","console","warn","type","returnUrl","sessionUrlProvider","getDefaultReturnUrl","startUrl","getStartUrl","projectNameForProxy","showInRecents","result","_openWebBrowserAsync","url","params","errorCode","authentication","dismiss","getRedirectUrl","path","urlPath","makeRedirectUri","native","scheme","isTripleSlashed","queryParams","preferLocalhost","useProxy","Platform","OS","ExecutionEnvironment","Standalone","Bare","includes","Constants","executionEnvironment","Linking","createURL","ipAddress","match","length","split","protocol","loadAsync","config","issuerOrDiscovery","request","AuthRequest","discovery","makeAuthUrlAsync"],"sourceRoot":"","sources":["../src/AuthSession.ts"],"sourcesContent":["import Constants, { ExecutionEnvironment } from 'expo-constants';\nimport * as Linking from 'expo-linking';\nimport { Platform } from 'expo-modules-core';\nimport {\n  dismissAuthSession,\n  openAuthSessionAsync,\n  WebBrowserAuthSessionResult,\n} from 'expo-web-browser';\n\nimport { AuthRequest } from './AuthRequest';\nimport {\n  AuthRequestConfig,\n  AuthRequestPromptOptions,\n  CodeChallengeMethod,\n  Prompt,\n  ResponseType,\n} from './AuthRequest.types';\nimport {\n  AuthSessionOptions,\n  AuthSessionRedirectUriOptions,\n  AuthSessionResult,\n} from './AuthSession.types';\nimport {\n  DiscoveryDocument,\n  fetchDiscoveryAsync,\n  Issuer,\n  IssuerOrDiscovery,\n  ProviderMetadata,\n  resolveDiscoveryAsync,\n} from './Discovery';\nimport { generateHexStringAsync } from './PKCE';\nimport { getQueryParams } from './QueryParams';\nimport sessionUrlProvider from './SessionUrlProvider';\n\nlet _authLock = false;\n\n// @needsAudit\n/**\n * Initiate a proxied authentication session with the given options. Only one `AuthSession` can be active at any given time in your application.\n * If you attempt to open a second session while one is still in progress, the second session will return a value to indicate that `AuthSession` is locked.\n *\n * @param options An object of type `AuthSessionOptions`.\n * @return Returns a Promise that resolves to an `AuthSessionResult` object.\n */\nexport async function startAsync(options: AuthSessionOptions): Promise<AuthSessionResult> {\n  const authUrl = options.authUrl;\n  // Prevent accidentally starting to an empty url\n  if (!authUrl) {\n    throw new Error(\n      'No authUrl provided to AuthSession.startAsync. An authUrl is required -- it points to the page where the user will be able to sign in.'\n    );\n  }\n  // Prevent multiple sessions from running at the same time, WebBrowser doesn't\n  // support it this makes the behavior predictable.\n  if (_authLock) {\n    if (__DEV__) {\n      console.warn(\n        'Attempted to call AuthSession.startAsync multiple times while already active. Only one AuthSession can be active at any given time.'\n      );\n    }\n\n    return { type: 'locked' };\n  }\n\n  const returnUrl = options.returnUrl || sessionUrlProvider.getDefaultReturnUrl();\n  const startUrl = sessionUrlProvider.getStartUrl(authUrl, returnUrl, options.projectNameForProxy);\n  const showInRecents = options.showInRecents || false;\n\n  // About to start session, set lock\n  _authLock = true;\n\n  let result: WebBrowserAuthSessionResult;\n  try {\n    result = await _openWebBrowserAsync(startUrl, returnUrl, showInRecents);\n  } finally {\n    // WebBrowser session complete, unset lock\n    _authLock = false;\n  }\n\n  // Handle failures\n  if (!result) {\n    throw new Error('Unexpected missing AuthSession result');\n  }\n  if (!('url' in result)) {\n    if ('type' in result) {\n      return result;\n    } else {\n      throw new Error('Unexpected AuthSession result with missing type');\n    }\n  }\n\n  const { params, errorCode } = getQueryParams(result.url);\n\n  return {\n    type: errorCode ? 'error' : 'success',\n    params,\n    errorCode,\n    authentication: null,\n    url: result.url,\n  };\n}\n\n// @needsAudit\n/**\n * Cancels an active `AuthSession` if there is one. No return value, but if there is an active `AuthSession`\n * then the Promise returned by the `AuthSession.startAsync()` that initiated it resolves to `{ type: 'dismiss' }`.\n */\nexport function dismiss() {\n  dismissAuthSession();\n}\n\nexport const getDefaultReturnUrl = sessionUrlProvider.getDefaultReturnUrl;\n\n// @needsAudit @docsMissing\n/**\n * Get the URL that your authentication provider needs to redirect to. For example: `https://auth.expo.io/@your-username/your-app-slug`. You can pass an additional path component to be appended to the default redirect URL.\n * > **Note** This method will throw an exception if you're using the bare workflow on native.\n *\n * @param path\n * @return\n *\n * @example\n * ```ts\n * const url = AuthSession.getRedirectUrl('redirect');\n *\n * // Managed: https://auth.expo.io/@your-username/your-app-slug/redirect\n * // Web: https://localhost:19006/redirect\n * ```\n *\n * @deprecated Use `makeRedirectUri({ path, useProxy })` instead.\n */\nexport function getRedirectUrl(path?: string): string {\n  return sessionUrlProvider.getRedirectUrl({ urlPath: path });\n}\n\n// @needsAudit\n/**\n * Create a redirect url for the current platform and environment. You need to manually define the redirect that will be used in\n * a bare workflow React Native app, or an Expo standalone app, this is because it cannot be inferred automatically.\n * - **Web:** Generates a path based on the current `window.location`. For production web apps, you should hard code the URL as well.\n * - **Managed workflow:** Uses the `scheme` property of your `app.config.js` or `app.json`.\n *   - **Proxy:** Uses `auth.expo.io` as the base URL for the path. This only works in Expo Go and standalone environments.\n * - **Bare workflow:** Will fallback to using the `native` option for bare workflow React Native apps.\n *\n * @param options Additional options for configuring the path.\n * @return The `redirectUri` to use in an authentication request.\n *\n * @example\n * ```ts\n * const redirectUri = makeRedirectUri({\n *   scheme: 'my-scheme',\n *   path: 'redirect'\n * });\n * // Custom app: my-scheme://redirect\n * // Expo Go: exp://127.0.0.1:19000/--/redirect\n * // Web dev: https://localhost:19006/redirect\n * // Web prod: https://yourwebsite.com/redirect\n *\n * const redirectUri2 = makeRedirectUri({\n *   scheme: 'scheme2',\n *   preferLocalhost: true,\n *   isTripleSlashed: true,\n * });\n * // Custom app: scheme2:///\n * // Expo Go: exp://localhost:19000\n * // Web dev: https://localhost:19006\n * // Web prod: https://yourwebsite.com\n *\n * const redirectUri3 = makeRedirectUri({\n *   useProxy: true,\n * });\n * // Custom app: https://auth.expo.io/@username/slug\n * // Expo Go: https://auth.expo.io/@username/slug\n * // Web dev: https://localhost:19006\n * // Web prod: https://yourwebsite.com\n * ```\n */\nexport function makeRedirectUri({\n  native,\n  scheme,\n  isTripleSlashed,\n  queryParams,\n  path,\n  preferLocalhost,\n  useProxy,\n  projectNameForProxy,\n}: AuthSessionRedirectUriOptions = {}): string {\n  if (\n    Platform.OS !== 'web' &&\n    native &&\n    [ExecutionEnvironment.Standalone, ExecutionEnvironment.Bare].includes(\n      Constants.executionEnvironment\n    )\n  ) {\n    // Should use the user-defined native scheme in standalone builds\n    return native;\n  }\n  if (!useProxy || Platform.OS === 'web') {\n    const url = Linking.createURL(path || '', {\n      isTripleSlashed,\n      scheme,\n      queryParams,\n    });\n\n    if (preferLocalhost) {\n      const ipAddress = url.match(\n        /\\b(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b/\n      );\n      // Only replace if an IP address exists\n      if (ipAddress?.length) {\n        const [protocol, path] = url.split(ipAddress[0]);\n        return `${protocol}localhost${path}`;\n      }\n    }\n\n    return url;\n  }\n  // Attempt to use the proxy\n  return sessionUrlProvider.getRedirectUrl({ urlPath: path, projectNameForProxy });\n}\n\n// @needsAudit\n/**\n * Build an `AuthRequest` and load it before returning.\n *\n * @param config A valid [`AuthRequestConfig`](#authrequestconfig) that specifies what provider to use.\n * @param issuerOrDiscovery A loaded [`DiscoveryDocument`](#discoverydocument) or issuer URL.\n * (Only `authorizationEndpoint` is required for requesting an authorization code).\n * @return Returns an instance of `AuthRequest` that can be used to prompt the user for authorization.\n */\nexport async function loadAsync(\n  config: AuthRequestConfig,\n  issuerOrDiscovery: IssuerOrDiscovery\n): Promise<AuthRequest> {\n  const request = new AuthRequest(config);\n  const discovery = await resolveDiscoveryAsync(issuerOrDiscovery);\n  await request.makeAuthUrlAsync(discovery);\n  return request;\n}\n\nasync function _openWebBrowserAsync(startUrl: string, returnUrl: string, showInRecents: boolean) {\n  const result = await openAuthSessionAsync(startUrl, returnUrl, { showInRecents });\n  if (result.type === 'cancel' || result.type === 'dismiss') {\n    return { type: result.type };\n  }\n\n  return result;\n}\n\nexport { useAutoDiscovery, useAuthRequest } from './AuthRequestHooks';\nexport { AuthError, TokenError } from './Errors';\n\nexport {\n  AuthSessionOptions,\n  AuthSessionRedirectUriOptions,\n  AuthSessionResult,\n  AuthRequest,\n  AuthRequestConfig,\n  AuthRequestPromptOptions,\n  CodeChallengeMethod,\n  DiscoveryDocument,\n  Issuer,\n  IssuerOrDiscovery,\n  Prompt,\n  ProviderMetadata,\n  ResponseType,\n  resolveDiscoveryAsync,\n  fetchDiscoveryAsync,\n  generateHexStringAsync,\n};\n\nexport {\n  // Token classes\n  TokenResponse,\n  AccessTokenRequest,\n  RefreshTokenRequest,\n  RevokeTokenRequest,\n  // Token methods\n  revokeAsync,\n  refreshAsync,\n  exchangeCodeAsync,\n  fetchUserInfoAsync,\n} from './TokenRequest';\n\n// Token types\nexport * from './TokenRequest.types';\n\n// Provider specific types\nexport { GoogleAuthRequestConfig } from './providers/Google';\nexport { FacebookAuthRequestConfig } from './providers/Facebook';\n"]},"metadata":{},"sourceType":"script"}