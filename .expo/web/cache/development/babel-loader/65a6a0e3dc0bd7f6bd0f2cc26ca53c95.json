{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _exportNames = {\n  digestStringAsync: true\n};\nexports.digestStringAsync = digestStringAsync;\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _wrapNativeSuper2 = _interopRequireDefault(require(\"@babel/runtime/helpers/wrapNativeSuper\"));\n\nvar _expoModulesCore = require(\"expo-modules-core\");\n\nvar _Crypto = require(\"./Crypto.types\");\n\nObject.keys(_Crypto).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _Crypto[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _Crypto[key];\n    }\n  });\n});\n\nvar _ExpoCrypto = _interopRequireDefault(require(\"./ExpoCrypto\"));\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nvar CryptoError = function (_TypeError) {\n  (0, _inherits2.default)(CryptoError, _TypeError);\n\n  var _super = _createSuper(CryptoError);\n\n  function CryptoError(message) {\n    var _this;\n\n    (0, _classCallCheck2.default)(this, CryptoError);\n    _this = _super.call(this, \"expo-crypto: \" + message);\n    _this.code = 'ERR_CRYPTO';\n    return _this;\n  }\n\n  return (0, _createClass2.default)(CryptoError);\n}((0, _wrapNativeSuper2.default)(TypeError));\n\nfunction assertAlgorithm(algorithm) {\n  if (!Object.values(_Crypto.CryptoDigestAlgorithm).includes(algorithm)) {\n    throw new CryptoError(\"Invalid algorithm provided. Expected one of: CryptoDigestAlgorithm.\" + Object.keys(_Crypto.CryptoDigestAlgorithm).join(', AlgCryptoDigestAlgorithmorithm.'));\n  }\n}\n\nfunction assertData(data) {\n  if (typeof data !== 'string') {\n    throw new CryptoError(\"Invalid data provided. Expected a string.\");\n  }\n}\n\nfunction assertEncoding(encoding) {\n  if (!Object.values(_Crypto.CryptoEncoding).includes(encoding)) {\n    throw new CryptoError(\"Invalid encoding provided. Expected one of: CryptoEncoding.\" + Object.keys(_Crypto.CryptoEncoding).join(', CryptoEncoding.'));\n  }\n}\n\nfunction digestStringAsync(_x, _x2) {\n  return _digestStringAsync.apply(this, arguments);\n}\n\nfunction _digestStringAsync() {\n  _digestStringAsync = (0, _asyncToGenerator2.default)(function* (algorithm, data) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      encoding: _Crypto.CryptoEncoding.HEX\n    };\n\n    if (!_ExpoCrypto.default.digestStringAsync) {\n      throw new _expoModulesCore.UnavailabilityError('expo-crypto', 'digestStringAsync');\n    }\n\n    assertAlgorithm(algorithm);\n    assertData(data);\n    assertEncoding(options.encoding);\n    return yield _ExpoCrypto.default.digestStringAsync(algorithm, data, options);\n  });\n  return _digestStringAsync.apply(this, arguments);\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AAEA;;AAGA;EAAA;EAAA;EAAA;EAAA;IAAA;IAAA;MAAA;IAAA;EAAA;AAAA;;AAFA;;;;;;IAIMA,W;;;;;EAGJ,qBAAYC,OAAZ,EAA2B;IAAA;;IAAA;IACzB,4CAAsBA,OAAtB;IADyB,MAF3BC,IAE2B,GAFpB,YAEoB;IAAA;EAE1B;;;iCALuBC,S;;AAQ1B,SAASC,eAAT,CAAyBC,SAAzB,EAAyD;EACvD,IAAI,CAACC,MAAM,CAACC,MAAP,CAAcC,6BAAd,EAAqCC,QAArC,CAA8CJ,SAA9C,CAAL,EAA+D;IAC7D,MAAM,IAAIL,WAAJ,yEACkEM,MAAM,CAACI,IAAP,CACpEF,6BADoE,EAEpEG,IAFoE,CAE/D,mCAF+D,CADlE,CAAN;EAKD;AACF;;AAED,SAASC,UAAT,CAAoBC,IAApB,EAAgC;EAC9B,IAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8B;IAC5B,MAAM,IAAIb,WAAJ,6CAAN;EACD;AACF;;AAED,SAASc,cAAT,CAAwBC,QAAxB,EAAgD;EAC9C,IAAI,CAACT,MAAM,CAACC,MAAP,CAAcS,sBAAd,EAA8BP,QAA9B,CAAuCM,QAAvC,CAAL,EAAuD;IACrD,MAAM,IAAIf,WAAJ,iEAC0DM,MAAM,CAACI,IAAP,CAC5DM,sBAD4D,EAE5DL,IAF4D,CAEvD,mBAFuD,CAD1D,CAAN;EAKD;AACF;;SAuBqBM,iB;;;;;uDAAf,WACLZ,SADK,EAELQ,IAFK,EAG0D;IAAA,IAA/DK,OAA+D,uEAAhC;MAAEH,QAAQ,EAAEC,uBAAeG;IAA3B,CAAgC;;IAE/D,IAAI,CAACC,oBAAWH,iBAAhB,EAAmC;MACjC,MAAM,IAAII,oCAAJ,CAAwB,aAAxB,EAAuC,mBAAvC,CAAN;IACD;;IAEDjB,eAAe,CAACC,SAAD,CAAf;IACAO,UAAU,CAACC,IAAD,CAAV;IACAC,cAAc,CAACI,OAAO,CAACH,QAAT,CAAd;IAEA,aAAaK,oBAAWH,iBAAX,CAA6BZ,SAA7B,EAAwCQ,IAAxC,EAA8CK,OAA9C,CAAb;EACD,C","names":["CryptoError","message","code","TypeError","assertAlgorithm","algorithm","Object","values","CryptoDigestAlgorithm","includes","keys","join","assertData","data","assertEncoding","encoding","CryptoEncoding","digestStringAsync","options","HEX","ExpoCrypto","UnavailabilityError"],"sourceRoot":"","sources":["../src/Crypto.ts"],"sourcesContent":["import { UnavailabilityError } from 'expo-modules-core';\n\nimport { CryptoDigestAlgorithm, CryptoEncoding, CryptoDigestOptions, Digest } from './Crypto.types';\nimport ExpoCrypto from './ExpoCrypto';\n\nexport * from './Crypto.types';\n\nclass CryptoError extends TypeError {\n  code = 'ERR_CRYPTO';\n\n  constructor(message: string) {\n    super(`expo-crypto: ${message}`);\n  }\n}\n\nfunction assertAlgorithm(algorithm: CryptoDigestAlgorithm): void {\n  if (!Object.values(CryptoDigestAlgorithm).includes(algorithm)) {\n    throw new CryptoError(\n      `Invalid algorithm provided. Expected one of: CryptoDigestAlgorithm.${Object.keys(\n        CryptoDigestAlgorithm\n      ).join(', AlgCryptoDigestAlgorithmorithm.')}`\n    );\n  }\n}\n\nfunction assertData(data: string): void {\n  if (typeof data !== 'string') {\n    throw new CryptoError(`Invalid data provided. Expected a string.`);\n  }\n}\n\nfunction assertEncoding(encoding: CryptoEncoding): void {\n  if (!Object.values(CryptoEncoding).includes(encoding)) {\n    throw new CryptoError(\n      `Invalid encoding provided. Expected one of: CryptoEncoding.${Object.keys(\n        CryptoEncoding\n      ).join(', CryptoEncoding.')}`\n    );\n  }\n}\n\n// @needsAudit\n/**\n * The `digestStringAsync()` method of `Crypto` generates a digest of the supplied `data` string with the provided digest `algorithm`.\n * A digest is a short fixed-length value derived from some variable-length input. **Cryptographic digests** should exhibit _collision-resistance_,\n * meaning that it's very difficult to generate multiple inputs that have equal digest values.\n * You can specify the returned string format as one of `CryptoEncoding`. By default, the resolved value will be formatted as a `HEX` string.\n * On web, this method can only be called from a secure origin (https) otherwise an error will be thrown.\n *\n * @param algorithm The cryptographic hash function to use to transform a block of data into a fixed-size output.\n * @param data The value that will be used to generate a digest.\n * @param options Format of the digest string. Defaults to: `CryptoDigestOptions.HEX`.\n * @return Return a Promise which fulfills with a value representing the hashed input.\n *\n * @example\n * ```ts\n * const digest = await Crypto.digestStringAsync(\n *   Crypto.CryptoDigestAlgorithm.SHA512,\n *   'ðŸ¥“ Easy to Digest! ðŸ’™'\n * );\n * ```\n */\nexport async function digestStringAsync(\n  algorithm: CryptoDigestAlgorithm,\n  data: string,\n  options: CryptoDigestOptions = { encoding: CryptoEncoding.HEX }\n): Promise<Digest> {\n  if (!ExpoCrypto.digestStringAsync) {\n    throw new UnavailabilityError('expo-crypto', 'digestStringAsync');\n  }\n\n  assertAlgorithm(algorithm);\n  assertData(data);\n  assertEncoding(options.encoding);\n\n  return await ExpoCrypto.digestStringAsync(algorithm, data, options);\n}\n"]},"metadata":{},"sourceType":"script"}